external function roundmode SetRoundModeD(Integer);external procedure EPFindTaxSum(string,date,val,var val,var val,string);external function boolean GetEPContractNextTRData(record EPContractVc,row EPContractVc,date,var date, var date,var date,var val,boolean,Boolean,string);external function string 255 GetEPContractData(record EPContractVc,date,string);external function string 255 EPContractFieldOnDate2(record EPContractVc,date,string);external function val amountofworkdays(date ,date,boolean ,string);external procedure CalcUserDays(record EPCalcResVc,record EPCalcDaysVc,string,var val,var date,var date,array integer,var integer);forward procedure CalcUserDaysPeriod(record EPCalcResVc,record EPCalcDaysVc,string,var val,var date,var date, date, date);external function longint datediff(date,date);external function val amountofworkdays(date,date,boolean,string);external function val amountofholidays(date,date,boolean,string);external function boolean GetEPContrChangeNextTRData(record EPContrChangeVc,row EPContrChangeVc,date,var date,var date,var date,var val,boolean,Boolean,string);//----------------------------------function integer getposinstr(string str1,string str2,integer start,boolean skip)begin  integer res,ls;  integer i,s;  res=(-1);  s=0;  ls=len(str1);  for (i=start;i<ls;i=i+1) begin    if (mid(str1,i,1)=="(") then begin s=s+1;end;    if (mid(str1,i,1)==")") then begin s=s-1;end;    if (mid(str1,i,1)==str2) then begin      if (skip) then begin        res=i;        i=ls+2;      end else begin        if (s==0) then begin          res=i;          i=ls+2;        end;      end;    end;  end;  getposinstr=res;  return;end;//would have put it in main FANALYSE function but need more dataglobalprocedure EPFindSplitSalary(record EPContractVc EPContractr,record EPCalcResVc EPCalcResr,var string tstr,Boolean checkobjf,string obj)begin  integer ls,delpos,delpos1;  integer typ; //0-undefined, 1 - number, 3 - function, 2 - variable  val res,wv,debres,credres,wv1;  string 1 fs,ftype;  string 255 ws,wexp;  string 21 dd;  string 60 objstr;  string 20 trtype,exp,fname;  date d1,d2;  string 1 DELIM;  row EPContractVc EPContractrw;  row EPCalcResVc EPCalcResrw;  string 20 timecl;  date nextsd;  integer i,ark,rwc,rw,initrwcnt,j;  date rsd,red,td;  boolean testf,TrHs,trHs2,foundf;  record EPCalcDaysVc EPCalcDayr;  val workdays,perworkdays,tval,empdays;  val daycnt,fres;  record EPContrChangeVc EPContrChanger;  row EPContrChangeVc EPContrChangerw;  array string 255 addedtr;  integer size;  date fsd,fed;  transaction string 1 gDelimCharacter;  if (blank(gDelimCharacter)) then begin    DELIM=",";  end else begin    DELIM = gDelimCharacter;  end;  exp = tstr;  fs=mid(exp,0,1);  typ=0;  ls=len(exp);  delpos=getposinstr(exp,"(",0,true);  if (delpos<>(-1)) then begin    fname=mid(exp,0,delpos);    wexp=mid(exp,delpos+1,ls-delpos-2);    ls=len(wexp);  end;  if (fname=="SALARY") then begin    delpos=getposinstr(wexp,DELIM,0,true);    trtype=mid(wexp,1,delpos-1);    delpos1=getposinstr(wexp,DELIM,delpos+1,true);    dd=Right(wexp,ls-delpos-2);    fsd = EPCalcResr.StartDate;    fsd.Day = 1;    fed = AddDay(AddMonth(fsd,1),-1);    EPCalcDayr.Code = dd;    foundf = false;    if (ReadFirstMain(EPCalcDayr,1,true)==false) then begin      //bad fix but don't want to add index in the middle of version TODO later      TrHs = true;      EPCalcDayr.Code = "";      while (LoopMain(EPCalcDayr,1,TrHs)) begin        if (EPCalcDayr.CalcStr==dd) then begin          TrHs = false;          foundf = true;        end;      end;    end;    if (foundf==false) then begin      goto LEPFindSplitSalary;    end;    ark = MatRowCnt(EPContractr);    for (i=0;i<ark;i=i+1) begin      MatRowGet(EPContractr,i,EPContractrw);      if (EPContractrw.TrType==trtype and (checkobjf==false or EPContractrw.Objects==obj) and EPContractrw.Type>0 and (blank(EPContractrw.ToDate) or EPContractrw.ToDate>EPCalcResr.EndDate)) then begin //take only valid trtypes        rsd = EPCalcResr.StartDate;        TrHs = true;        res = 0;        While (GetEPContractNextTRData(EPContractr,EPContractrw,EPCalcResr.EndDate,rsd,red,nextsd,res,TrHs,checkobjf,obj)) begin          timecl = EPContractFieldOnDate2(EPContractr,rsd,"TimeClass");          workdays = amountofworkdays(fsd,fed,true,timecl);          perworkdays = amountofworkdays(rsd,nextsd,true,timecl);          //tval = res * perworkdays/workdays;          daycnt = 0;          td = nextsd;          CalcUserDaysPeriod(EPCalcResr,EPCalcDayr,timecl,daycnt,td,td,rsd,nextsd);          fres = fres + (res*daycnt/workdays);//          stopalert(daycnt & ":" & workdays & ":" & res & ":" & dd & ";" & ReadFirstMain(EPCalcDayr,1,true));          rsd = AddDay(nextsd,1);          addedtr[size] = EPContractrw.TrType;          size = size + 1;          if (nextsd>=EPCalcResr.EndDate) then begin            TrHs = false;          end;        end;      end;    end;    TrHs = true;    EPContrChanger.StartDate = "";    while (LoopKey("StartDate:" & EPContractr.ContractNr,EPContrChanger,1,TrHs)) begin      if (EPContrChanger.StartDate>EPCalcResr.EndDate) then begin        TrHs = false;      end else begin        testf = true;        if (nonblank(EPContrChanger.EndDate) and EPContrChanger.EndDate < EPCalcResr.StartDate) then begin          testf = false;        end;        if (EPContrChanger.Status==0) then begin          testf = false;        end;        if (testf) then begin          rwc = MatRowCnt(EPContrChanger);          for (rw=0;rw<rwc;rw=rw+1) begin            MatRowGet(EPContrChanger,rw,EPContrChangerw);            if (EPContrChangerw.Type>0) then begin              for (j=0;j<size;j=j+1) begin                if (addedtr[j]==EPContrChangerw.TrType) then begin goto LSkipAddRestType; end;              end;              rsd = EPContrChanger.StartDate;              red = "";              nextsd ="";              TrHs2 = true;              while (GetEPContrChangeNextTRData(EPContrChanger,EPContrChangerw,EPCalcResr.EndDate,rsd,red,nextsd,res,TrHs2,checkobjf,obj)) begin                if (DateInRange(EPCalcResr.StartDate,rsd,red) or DateInRange(EPCalcResr.EndDate,rsd,red)) then begin                  if (rsd<EPCalcResr.StartDate) then begin                    rsd = EPCalcResr.StartDate;                  end;                  timecl = EPContractFieldOnDate2(EPContractr,rsd,"TimeClass");                  workdays = amountofworkdays(fsd,fed,true,timecl);                  perworkdays = amountofworkdays(rsd,red,true,timecl);                  //tval = res * perworkdays/workdays;                  td = nextsd;                  CalcUserDaysPeriod(EPCalcResr,EPCalcDayr,timecl,daycnt,td,td,rsd,nextsd);                  fres = fres + (res*daycnt/workdays);                  for (j=0;j<size;j=j+1) begin                    if (addedtr[j]==EPContrChangerw.TrType) then begin goto LSkipTrAdd2; end;                  end;                  addedtr[size] = EPContrChangerw.TrType;                  size = size + 1;              LSkipTrAdd2:;                end;                rsd = AddDay(nextsd,1);                if (nextsd>=EPCalcResr.EndDate) then begin                  TrHs2 = false;                  goto LSkipAddRestType;                end;                res = 0;              end;            end;         LSkipAddRestType:;          end;        end;      end;    end;    tstr = ValToString(fres,M423Val,"",".",0);  end;LEPFindSplitSalary:;  return;end;globalprocedure CalcUserDaysPeriod(record EPCalcResVc EPCalcResr,record EPCalcDaysVc EPCalcDayr,string timecl,var val days,var date d1,var date d2, date start, date ends)begin  row EPCalcDaysVc EPCalcDayrw;  row EPCalcResVc EPCalcResrw;  record EPOffWorkVc EPOffWorkr;  date sd,ed;  boolean periodf,monthf;  integer rw,rwc;  integer rw2,rwc2;  integer res;  integer i;  boolean Trhs,testf,dayf;  d1 = "";  d2 = "";  rwc = MatRowCnt(EPCalcDayr);  for (rw=0;rw<rwc;rw=rw+1) begin    MatRowGet(EPCalcDayr,rw,EPCalcDayrw);    dayf = true;    res = 0;    switch (EPCalcDayrw.ActionType) begin      case 0:              if (EPCalcDayrw.DayType==3) then begin                rwc2 = MatRowCnt(EPCalcResr);                for (rw2=0;rw2<rwc2;rw2=rw2+1) begin                  MatRowGet(EPCalcResr,rw2,EPCalcResrw);                  if (EPCalcDayrw.OffWorkGroup==EPCalcResrw.TrType) then begin                    days = days + EPCalcResrw.Sum;                  end;                end;              end;              dayf = false;      case 1:              sd = start; ed = ends;              periodf = true;      case 2:              sd = AddDay(start,-GetDay(start)+1);              ed = AddDay(sd,DaysInMonth(getyear(start),Getmonth(start))-1);              monthf = true;      case 3: // include if starts in period              if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin                Trhs = true;                Resetloop(EPOffWorkr);                EPOffWorkr.ContractNr = EPCalcResr.ContractNr;                EPOffWorkr.EmpCode = EPCalcResr.EmpCode;                while (LoopKey("EmpCode",EPOffWorkr,1,TrHs)) begin                  testf = true;                  if (EPoffWorkr.ContractNr<>EPCalcResr.ContractNr) then begin                  	if  !(EPOffWorkr.ContractNr=="" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode) then begin                      testf = false;                     end;                  end;                  if (EPOffWorkr.EmpCode<>EPCalcResr.EmpCode) then begin										testf = false;										trhs = false;									end;                  if (EPOffWorkr.Group<>EPCalcDayrw.OffWorkGroup) then begin                    testf = false;                  end;                  if (EPOffWorkr.OKFlag==0) then begin                    testf = false;                  end;                  if (testf) then begin                    if (EPOffWorkr.StartDate<=ends and EPOffWorkr.StartDate>=start) then begin                      dayf = false;                      if (Periodf) then begin                        if (EPOffWorkr.StartDate<start) then begin                          sd = EPOffWorkr.StartDate;                          ed = AddDay(start,-1);                          dayf = true;                        end;                      end else begin                        sd = EPOffWorkr.StartDate;                        ed = EPOffWorkr.EndDate;                        dayf = true;                      end;                      if (dayf) then begin                        switch EPCalcDayrw.DayType begin                          case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days                          case 1: res = DateDiff(ed,sd)+1;//calendar days                          case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays                        end;                        days = days + res;                        if (sd < d1 and nonblankDate(d1)) then begin d1 = sd; end;                        if (blankdate(d1)) then begin d1 = sd; end;                        if (ed > d2) then begin d2 = ed; end;                      end;                    end;                  end;                end;              end;              dayf = false;      case 4: // include if at ending              if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin                Trhs = true;                Resetloop(EPOffWorkr);                EPOffWorkr.ContractNr = EPCalcResr.ContractNr;                EPOffWorkr.EmpCode = EPCalcResr.EmpCode;                while (LoopKey("EmpCode",EPOffWorkr,1,TrHs)) begin                  testf = true;                  if (EPoffWorkr.ContractNr<>EPCalcResr.ContractNr) then begin                    if !(EPOffWorkr.ContractNr=="" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode) then begin                      testf = false;                    end;                  end;                  if (EPOffWorkr.EmpCode<>EPCalcResr.EmpCode) then begin                    testf = false;                    trhs = false;                  end;                  if (EPOffWorkr.Group<>EPCalcDayrw.OffWorkGroup) then begin                    testf = false;                  end;                  if (EPOffWorkr.OKFlag==0) then begin                    testf = false;                  end;                  if (testf) then begin                    if (EPOffWorkr.StartDate>=start and EPoffWorkr.StartDate<=ends) then begin                      dayf = false;                      if (Periodf) then begin                        if (EPOffWorkr.EndDate>ends) then begin                          sd = AddDay(ends,1);                          ed = ends;                          dayf = true;                        end;                      end else begin                        sd = EPOffWorkr.StartDate;                        ed = EPOffWorkr.EndDate;                        dayf = true;                      end;                      if (dayf) then begin                        switch EPCalcDayrw.DayType begin                          case 0:                          res = AmountOfWorkDays(sd,ed,false,timecl);//work days                          case 1: res = DateDiff(ed,sd)+1;//calendar days                          case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays                        end;                        days = days + res;                        if (sd < d1 and nonblankDate(d1)) then begin d1 = sd; end;                        if (blankdate(d1)) then begin d1 = sd; end;                        if (ed > d2) then begin d2 = ed; end;                      end;                    end;                  end;                end;              end;              dayf = false;     case 5: // substract if at begining              if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin                Trhs = true;                Resetloop(EPOffWorkr);                EPOffWorkr.EmpCode = EPCalcResr.EmpCode;                while (LoopKey("EmpCode",EPOffWorkr,1,TrHs)) begin                  testf = true;                  if (EPoffWorkr.ContractNr<>EPCalcResr.ContractNr) then begin                    if !(EPOffWorkr.ContractNr=="" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode) then begin                      testf = false;                    end;                  end;                  if (EPOffWorkr.EmpCode<>EPCalcResr.EmpCode) then begin                    testf = false;                    trhs = false;                  end;                  if (EPOffWorkr.Group<>EPCalcDayrw.OffWorkGroup) then begin                    testf = false;                  end;                  if (EPOffWorkr.OKFlag==0) then begin                    testf = false;                  end;                  if (testf) then begin                    if (EPOffWorkr.EndDate>=start and EPoffWorkr.EndDate<=ends) then begin                      if (EPOffWorkr.StartDate<start) then begin                        sd = start;                        ed = EPOffWorkr.EndDate;                      end else begin                        sd = EPOffWorkr.StartDate;                        ed = EPOffWorkr.EndDate;                      end;                      switch (EPCalcDayrw.DayType) begin                        case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days                        case 1: res = DateDiff(ed,sd)+1;//calendar days                        case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays                      end;                      days = days - res;                    end;                  end;                end;              end;              dayf = false;     case 6: //substract if at ending              if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin                Trhs = true;                Resetloop(EPOffWorkr);                EPOffWorkr.ContractNr = EPCalcResr.ContractNr;                EPOffWorkr.EmpCode = EPCalcResr.EmpCode;                while (LoopKey("EmpCode",EPOffWorkr,1,TrHs)) begin                  testf = true;                  if (EPoffWorkr.ContractNr<>EPCalcResr.ContractNr) then begin                    if !(EPOffWorkr.ContractNr=="" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode) then begin                      testf = false;                    end;                  end;                  if (EPOffWorkr.EmpCode<>EPCalcResr.EmpCode) then begin                    testf = false;                    trhs = false;                  end;                  if (EPOffWorkr.Group<>EPCalcDayrw.OffWorkGroup) then begin                    testf = false;                  end;                  if (EPOffWorkr.OKFlag==0) then begin                    testf = false;                  end;                  if (testf) then begin                    if (EPOffWorkr.StartDate>=start and EPoffWorkr.StartDate<=ends) then begin                      if (EPOffWorkr.EndDate>ends) then begin                        sd = EPOffWorkr.StartDate;                        ed = ends;                      end else begin                        sd = EPOffWorkr.StartDate;                        ed = EPOffWorkr.EndDate;                      end;                      switch EPCalcDayrw.DayType begin                        case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days                        case 1: res = DateDiff(ed,sd)+1;//calendar days                        case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays                      end;                      days = days - res;                    end;                  end;                end;              end;              dayf = false;     case 7: //add always              if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin                Trhs = true;                Resetloop(EPOffWorkr);                EPOffWorkr.ContractNr = EPCalcResr.ContractNr;                EPOffWorkr.EmpCode = EPCalcResr.EmpCode;                while (LoopKey("EmpCode",EPOffWorkr,1,TrHs)) begin                  testf = true;                  if (EPoffWorkr.ContractNr<>EPCalcResr.ContractNr) then begin                    if !(EPOffWorkr.ContractNr=="" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode) then begin                      testf = false;                    end;                  end;                  if (EPOffWorkr.EmpCode<>EPCalcResr.EmpCode) then begin                    testf = false;                    trhs = false;                  end;                  if (EPOffWorkr.Group<>EPCalcDayrw.OffWorkGroup) then begin                    testf = false;                  end;                  if (EPOffWorkr.OKFlag==0) then begin                    testf = false;                  end;                  if (testf) then begin                    if (EPOffWorkr.StartDate<=ends and EPOffWorkr.EndDate>=start) then begin                      dayf = false;                      if (periodf) then begin                        if (EPOffWorkr.StartDate<start) then begin                          sd = EPOffWorkr.StartDate;                          ed = AddDay(start,-1);                          switch EPCalcDayrw.DayType begin                            case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days                            case 1: res = DateDiff(ed,sd)+1;//calendar days                            case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays                          end;                          days = days + res;                          if (sd < d1 and nonblankDate(d1)) then begin d1 = sd; end;                          if (blankdate(d1)) then begin d1 = sd; end;                          if (ed > d2) then begin d2 = ed; end;                        end;                        if (EPOffWorkr.EndDate>ends) then begin                          sd = AddDay(ends,1);                          ed = EPOffWorkr.EndDate;                          dayf = true;                        end;                      end else begin                        sd = EPOffWorkr.StartDate;                        ed = EPOffWorkr.EndDate;                        dayf = true;                      end;                      if (dayf) then begin                        switch (EPCalcDayrw.DayType) begin                          case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days                          case 1: res = DateDiff(ed,sd)+1;//calendar days                          case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays                        end;                        days = days + res;                        if (sd < d1 and nonblankDate(d1)) then begin d1 = sd; end;                        if (blankdate(d1)) then begin d1 = sd; end;                        if (ed > d2) then begin d2 = ed; end;                      end;                    end;                  end;                end;              end;              dayf = false;   case 8: //substract always              if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin                TrHs = true;                Resetloop(EPOffWorkr);                EPOffWorkr.ContractNr = EPCalcResr.ContractNr;                EPOffWorkr.EmpCode = EPCalcResr.EmpCode;                while (LoopKey("EmpCode",EPOffWorkr,1,TrHs)) begin                  testf = true;                  if (EPoffWorkr.ContractNr<>EPCalcResr.ContractNr) then begin                    if !(EPOffWorkr.ContractNr=="" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode) then begin                      testf = false;                    end;                  end;                  if (EPOffWorkr.EmpCode<>EPCalcResr.EmpCode) then begin                    testf = false;                    trhs = false;                  end;                  if (EPOffWorkr.Group<>EPCalcDayrw.OffWorkGroup) then begin                    testf = false;                  end;                  if (EPOffWorkr.OKFlag==0) then begin                    testf = false;                  end;                  if (testf) then begin                    if (EPOffWorkr.StartDate<=ends and EPOffWorkr.EndDate>=start) then begin                      if (EPOffWorkr.StartDate<start) then begin                        sd = start;                      end else begin                        sd = EPOffWorkr.StartDate;                      end;                      if (EPOffWorkr.EndDate>ends) then begin                        ed = ends;                      end else begin                        ed = EPOffWorkr.EndDate;                      end;                      switch EPCalcDayrw.DayType begin                        case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days                        case 1: res = DateDiff(ed,sd)+1;//calendar days                        case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays                      end;                      days = days - res;                      if (EPOffWorkr.StartDate<=d1 and ed<=d2 and ed>d1 and nonblankDate(d1)) then begin                        d1 = addday(ed,1);                      end;                    end;                  end;                end;              end;              dayf = false;      case 9:             if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin               TrHs = true;               Resetloop(EPOffWorkr);               EPOffWorkr.ContractNr = EPCalcResr.ContractNr;               EPOffWorkr.EmpCode = EPCalcResr.EmpCode;               while LoopKey("EmpCode",EPOffWorkr,1,TrHs) begin                  testf = true;                  if (EPoffWorkr.ContractNr <> EPCalcResr.ContractNr) then begin                    if (not (EPOffWorkr.ContractNr== "" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode)) then begin                      testf = false;                    end;                  end;                  if (EPOffWorkr.EmpCode <> EPCalcResr.EmpCode) then begin                    testf = false;                    trhs = false;                  end;                  if (EPOffWorkr.Group <> EPCalcDayrw.OffWorkGroup) then begin                    testf = false;                  end;                  if (EPOffWorkr.OKFlag==0) then begin                    testf = false;                  end;                  if (EPOffWorkr.EndDate < EPCalcResr.StartDate) then begin                    testf = false;                  end;                  if (EPOffWorkr.StartDate > EPCalcResr.EndDate) then begin                    testf = false;                  end;                  if (testf) then begin                    if (EPOffWorkr.StartDate < EPCalcResr.StartDate) then begin                      sd = EPCalcResr.StartDate;                    end else begin                      sd = EPOffWorkr.StartDate;                    end;                    if (EPOffWorkr.EndDate > EPCalcResr.EndDate) then begin                      ed = EPCalcResr.EndDate;                    end else begin                      ed = EPOffWorkr.EndDate;                    end;                    switch EPCalcDayrw.DayType begin                      case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days                      case 1: res = DateDiff(ed,sd)+1;//calendar days                      case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays                    end;                    days = days + res;                    if (sd < d1 and nonblankDate(d1)) then begin d1 = sd; end;                    if (blankdate(d1)) then begin d1 = sd; end;                    if (ed > d2) then begin d2 = ed; end;                  end;                end;              end;              dayf = false;        case 10:      othervise:        dayf = false;    end;    if (dayf) then begin        switch (EPCalcDayrw.DayType) begin          case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days          case 1: res = DateDiff(ed,sd)+1;//calendar days          case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays        end;      days = days + res;      if (sd<d1 and nonblankDate(d1)) then begin d1 = sd; end;      if (blankdate(d1)) then begin d1 = sd; end;      if (ed>d2) then begin d2 = ed; end;    end;  end;return;end;