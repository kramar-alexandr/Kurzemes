external procedure AddEPEntryVal(record EPCalcResVc,string,val,integer);
external function Time TimeDiff(Time,Time);
external function val CalcConst(date,date,val,val,array integer);
external procedure addvarvalAdd(string,var record SMVc,string);
external procedure UpdateAvMonth(var record EPCalcResVc);
external procedure addvarval(string,var record SMVc,string);
external function longint datediff(date,date);
external function val amountofworkdays(date,date,boolean,string);
external function val amountofworkhours(string,date,date,boolean,string,Boolean);
external function val amountofholidays(date,date,boolean,string);
external Function val FCALCWITHVARPay(string,var record SMVc,string);
external function Boolean IsEPHolliday(Date,record BHollVc ,record TimeClassVc ,Boolean ,boolean );
external function roundmode SetRoundModeD(Integer);
external function val GetAvSalDays(record EPCalcResVc,integer);
external procedure calculatePrivilegies(record EPCalcResVc,var array string,var array val,var array integer,var integer);
external procedure GetFullCurncyRate(var string,Date,var val,var val,var val,var val,var val);
external function val DivRateToBase1(string,val,val,val,val,val,val,roundmode);
external function val MulRateToBase1(var string,val,val,val,val,val,val,roundmode);
external function LongInt MonthDiff(Date,Date);
external function string 255 EPContractFieldOnDate(string,date,string);
external procedure EPFindSplitSalary(record EPContractVc,record EPCalcResVc,var string,Boolean,string);
external procedure EPCalc(var record EPCalcResVc,row EPEntryVc,record EPEntrySetBlock);
external function val GetTimeTableDays(date,date,string);

procedure GetContractBase(record EPContractVc EPContractr,record EPPayrollSetBlock EPPayrollSetr,var val res,date sd,date ed)
begin
  row EPContractVc EPContractrw;
  string 20 timecl;
  integer i,ark,rwc,rw,initrwcnt;
  val workdays,perworkdays;
  date rsd,red;
  
  boolean testf;  
  if (EPContractr.TimeClass != "") then begin
    timecl = EPContractr.TimeClass;   
  end else begin
    timecl = EPPayrollSetr.DefTimeClass;
  end;
  workdays = amountofworkdays(sd,ed,true,timecl);
  ark=MatRowCnt(EPContractr);
  for (i=0;i<ark;i=i+1) begin
    MatRowGet(EPContractr,i,EPContractrw);
    if (EPContractrw.Type==2) then begin
      rsd = sd;
      red = ed;
      testf = true;
      if (nonblank(EPContractrw.FromDate)) then begin
        if (dateinrange(EPContractrw.FromDate,sd,ed)) then begin
         rsd = EPContractrw.FromDate;
        end else begin
          if (EPContractrw.FromDate > ed) then begin
            testf = false;
          end;
        end;
      end;        
      if (nonblank(EPContractrw.ToDate)) then begin
        if (dateinrange(EPContractrw.ToDate,sd,ed)) then begin
          red = EPContractrw.ToDate;
        end else begin
          if (EPContractrw.ToDate < sd) then begin
            testf = false;
          end;
        end;
      end;
      if (testf) then begin
        perworkdays = amountofworkdays(rsd,red,true,timecl);                  
        res = res + Round(EPContractrw.Sum/workdays * perworkdays,SetRoundModeD(2));
      end;
    end;
  end;
return;
end;

function val GetAvSalHours(record EPCalcResVc EPCalcResr,record EPPayrollSetBlock EPSetBl)
begin
  val res;
  integer i,rwcnt;
  string 20 tstr;
  row EPCalcResVc EPCalcResrw;
  Boolean foundf;

  res = 0;
  tstr = EPSetBl.VacHourType;
  rwcnt = MatRowCnt(EPCalcResr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(EPCalcResr,i,EPCalcResrw);
    if (EPCalcResrw.TrType==tstr) then begin
      i = rwcnt;
      res = EPCalcResrw.Sum;
      foundf = true;
    end;
  end;
  
  if (!foundf) then begin
    res = amountofworkhours(EPCalcResr.ContractNr,EPCalcResr.StartDate,EPCalcResr.EndDate,true,EPContractFieldOnDate(EPCalcResr.ContractNr,EPCalcResr.StartDate,"TimeClass"),false);
  end;

  GetAvSalHours = res;
  return;
end;

function val GetEPValueConverted(date td,date pd,val tval)
begin
  val res;
  record EPConversionBlock EPConvBl;
  val frrate,torate,torate2,br1,br2;
  
  res = tval;
  BlockLoad(EPConvBl);
  if (td>=EPConvBl.ConvDate and pd<EPConvBl.ConvDate) then begin
    GetFullCurncyRate(EPConvBl.OldCurncy,pd,frrate,torate,torate2,br1,br2);
    res = MulRateToBase1(EPConvBl.OldCurncy,tval,frrate,torate,torate2,br1,br2,DefaultCurRoundOff);
  end;  
  
  GetEPValueConverted = res;
  return;
end;

function Boolean LongOffWorkStarted(record EPCalcResVc EPCalcResr,Date td)
begin
  Boolean res,TrHs,testf;
  Date ed;
  record EPOffWorkVc EPOffWorkr;
  
  EPOffWorkr.EndDate = td;
  ed = AddDay(AddMonth(td,1),-1);
  TrHs = true;
  while (LoopKey("EndDate",EPOffWorkr,1,TrHs)) begin
    if (EPOffWorkr.EndDate>ed) then begin
      TrHs = false;
    end else begin
      testf = true;
      if (EPOffWorkr.EndDate>ed) then begin
        testf = false;
      end;
      if (EPOffWorkr.ContractNr!=EPCalcResr.ContractNr) then begin
        testf = false;
      end;
      if (testf) then begin
        if (GetMonth(EPCalcResr.StartDate)==GetMonth(EPOffWorkr.StartDate)) then begin
          res = true;
        end;
      end;
    end;
  end;

  LongOffWorkStarted = res;
  return;
end;

function Date LongOffWorkStarted2(string contractnr,Date td)
begin
  Boolean TrHs,testf;
  Date ed,res;
  record EPOffWorkVc EPOffWorkr;
  
  EPOffWorkr.EndDate = td;
  ed = AddDay(AddMonth(td,1),-1);
  TrHs = true;
  while (LoopKey("EndDate",EPOffWorkr,1,TrHs)) begin
    if (EPOffWorkr.EndDate>ed) then begin
      TrHs = false;
    end else begin
      testf = true;
      if (EPOffWorkr.EndDate>ed) then begin
        testf = false;
      end;
      if (EPOffWorkr.ContractNr!=contractnr) then begin
        testf = false;
      end;
      if (testf) then begin
        res = EPOffWorkr.StartDate;
      end;
    end;
  end;

  LongOffWorkStarted2 = res;
  return;
end;

procedure AddValObjectToArray(var array val a_sal,var array string a_obj,val sum,string obj)
begin
  Integer i,pos;
  Boolean foundf;
  
  for (i=0;i<a_sal.length;i=i+1) begin
    if (a_obj[i]==obj) then begin
      a_sal[i] = a_sal[i] + sum;
      foundf = true;
    end;
  end;
  
  if (!foundf) then begin
    a_sal[a_sal.length] = sum;
    a_obj[a_obj.length] = obj;
  end;

  return;
end;

procedure GetMonthSalaryWithObjects(record EPCalcResVc EPCalcResr,var array val a_sal,var array string a_obj)
begin
  record EPTrTypeVc EPTrTyper;
  row EPCalcResVc EPCalcResrw;
  Integer i,rwcnt;
  Boolean TrHs;
  string 255 list;

  EPTrTyper.AvSalType = 1;
  TrHs = true;
  while LoopKey("AvSalType",EPTrTyper,1,trhs) begin
    if (EPtrTyper.AvSalType<>1) then begin
      TrHs = false;
    end else begin
      if (nonblank(list)) then begin
        list = list & ",";
      end;
      list = list & EPTrTyper.Code;
    end;
  end;
  
  rwcnt = MatRowCnt(EPCalcResr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(EPCalcResr,i,EPCalcResrw);
    if (SetInSet(EPCalcResrw.TrType,list)) then begin
      AddValObjectToArray(a_sal,a_obj,EPCalcResrw.Sum,EPCalcResrw.Objects);
    end;
  end;

  return;
end;

function val GetMonthAvaregeSalaryCalc(record EPCalcResVc EPCalcResr)
begin
  record EPTrTypeVc EPTrTyper;
  row EPCalcResVc EPCalcResrw;
  Integer i,rwcnt;
  Boolean TrHs;
  string 255 list;
  val res;

  EPTrTyper.AvSalType = 1;
  TrHs = true;
  while LoopKey("AvSalType",EPTrTyper,1,trhs) begin
    if (EPtrTyper.AvSalType<>1) then begin
      TrHs = false;
    end else begin
      if (nonblank(list)) then begin
        list = list & ",";
      end;
      list = list & EPTrTyper.Code;
    end;
  end;
  
  rwcnt = MatRowCnt(EPCalcResr);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(EPCalcResr,i,EPCalcResrw);
    if (SetInSet(EPCalcResrw.TrType,list)) then begin
      res = res + EPCalcResrw.Sum;
    end;
  end;

  GetMonthAvaregeSalaryCalc = res;
  return;
end;

procedure ShowWhiteSpace(integer cnt)
begin
  integer i;
  
    for (i=0;i<cnt;i=i+1) begin
      OutString(0,0,"",false);
    end;
    
  return;
end;

procedure AddCalcResToAvSalCalc(record EPCalcResVc EPCalcResr,record EPContractVc EPContractr,record EPPayrollSetBlock EPSetBl,Integer monthcount,Date dateto,Date dateto2,var val saltot,var val daytot,var val hourtot,Boolean repf,Boolean readf,Boolean ratef,date exclper,Boolean checkmonthf,var array val a_saltot,var array string a_objtot)
begin
  val t,t2;
  val msal;
  array val a_sal;
  array string 255 a_obj;
  Integer i;

  t = GetAvSalDays(EPCalcResr,0);
  t2 = GetAvSalHours(EPCalcResr,EPSetbl);
  hourtot = hourtot + t2;
  daytot = daytot + t;

  if (EPSetBl.ObjectsAvSalary) then begin
    ClearArray(a_sal);
    ClearArray(a_obj);
    GetMonthSalaryWithObjects(EPCalcResr,a_sal,a_obj);
    for (i=0;i<a_sal.length;i=i+1) begin
      AddValObjectToArray(a_saltot,a_objtot,a_sal[i],a_obj[i]);
      saltot = saltot + a_sal[i];
      if (repf) then begin
        StartFormat(15);
        if (i==0) then begin
          OutString(20,0,UsetStr(1525117),false);
          OutString(110,"DblCalcRes",EPCalcResr.SerNr,false);
          OutString(180,0,EPCalcResr.StartDate,false);
          OutString(230,0,EPCalcResr.EndDate,false);
        end else begin
          ShowWhiteSpace(2);
        end;
        OutString(270,0,a_obj[i],false);
        OutString(340,0,a_sal[i],true);
        OutSTring(400,0,t,true);
        if (ratef) then begin
          OutSTring(460,0,t2,true);
        end;
        EndFormat;
      end;
    end;
  end else begin
    msal = GetEPValueConverted(dateto2,EPCalcResr.StartDate,EPCalcResr.MonthSal);
    saltot = saltot + msal;
    if (repf) then begin
      StartFormat(15);
      OutString(20,0,UsetStr(1525117),false);
      OutString(110,"DblCalcRes",EPCalcResr.SerNr,false);
      OutString(180,0,EPCalcResr.StartDate,false);
      OutString(230,0,EPCalcResr.EndDate,false);
      OutString(340,0,msal,true);
      OutSTring(400,0,t,true);
      if (ratef) then begin
        OutSTring(460,0,t2,true);
      end;
      EndFormat;
    end;
  end;


  return;
end;

procedure GetEPAvSalaryFind(record EPContractVc EPContractr,record EPPayrollSetBlock EPSetBl,Integer monthcount,Date dateto,Date dateto2,var val saltot,var val daytot,var val hourtot,Boolean repf,Boolean readf,Boolean hourf,date exclper,Boolean checkmonthf,var array val a_saltot,var array string a_objtot,var Boolean refreshf,record EPCalcResVc tEPCalcResr)
begin
  Date datefrom,tsd;
  record EPCalcResVc EPCalcResr;
  val t,t2;
  val msal;
  record EPInitAmountsVc EPInitr;
  row EPInitAmountsVc EPInitrw;
  Boolean TrHs,testf;
  integer rw,rwc;
  array val a_sal;
  array string 255 a_obj;
  Integer i,cnt;
  row EPEntryVc EPEntryrw;

  datefrom = addday(dateto,-getday(dateto));
  datefrom = addmonth(dateto,-monthcount);

  if (readf) then begin
    EPInitr.EmpCode = EPContractr.EmpCode;
    if (ReadFirstMain(EPInitr,1,true)) then begin
      rwc = MatRowCnt(EPInitr);
      for (rw=rwc-1;rw>=0;rw=rw-1) begin
        MatRowGet(EPInitr,rw,EPInitrw);
        testf = true;
        if (dateinrange(EPInitrw.DateFrom,datefrom,dateto)==false) then begin
          testf = false;
        end;
        if (dateinrange(EPInitrw.DateTo,datefrom,dateto)==false) then begin
          testf = false;
        end;
        if (testf) then begin
          msal = GetEPValueConverted(dateto2,EPInitrw.DateFrom,EPInitrw.Sum);
          if (EPSetBl.ObjectsAvSalary) then begin
            AddValObjectToArray(a_saltot,a_objtot,EPInitrw.Sum,EPInitrw.Object);
          end;
          saltot = saltot + msal;
          if (EPInitrw.Days>0) then begin
            daytot = daytot + EPInitrw.Days;
          end;
          if (EPInitrw.Hours>0) then begin
            hourtot = hourtot + EPInitrw.Hours;
          end;
          if (repf) then begin
            StartFormat(15);
            OutString(20,0,UsetStr(1525118),false);
            OutString(180,0,EPInitrw.DateFrom,false);
            OutString(230,0,EPInitrw.DateTo,false);
            OutString(270,0,EPInitrw.Object,false);
            OutString(340,0,msal,true);
            OutSTring(400,0,EPInitrw.Days,true);
            if (hourf) then begin
              OutSTring(460,0,EPInitrw.Hours,true);
            end;
            //OutString(440,0,datefrom & " " & dateto,true);
            EndFormat;
          end;
          cnt = cnt + 1;
        end;
      end;
    end;
  end;

  EPCalcResr.ContractNr = EPContractr.ContractNr;
  Trhs = true;
  while (loopKey("ContractNr",EPCalcResr,1,Trhs)) begin
    testf = true;
    if (EPCalcresr.ContractNr!=EPContractr.ContractNr) then begin
      Trhs = false;
    end;
    if (dateinrange(EPCalcResr.StartDate,datefrom,dateto)==false) then begin
      testf = false;
    end;
    if (dateinrange(EPCalcResr.EndDate,datefrom,dateto)==false) then begin
      testf = false;
    end;
    if (EPCalcResr.StartDate==exclper) then begin
      testf = false;
    end;
    if (testf and checkmonthf and LongOffWorkStarted(EPCalcResr,addday(dateto2,-getday(dateto2)+1))) then begin
      testf = false;
    end;
    if (trhs and testf) then begin
      AddCalcResToAvSalCalc(EPCalcResr,EPContractr,EPSetBl,monthcount,dateto,dateto2,saltot,daytot,hourtot,repf,readf,hourf,exclper,checkmonthf,a_saltot,a_objtot);
      cnt = cnt + 1;
    end;
  end;
 
  if (cnt==0 or (cnt<monthcount and EPSetBl.IncludeCurrentMonth==1)) then begin
    refreshf = true;    
    if (nonblank(tEPCalcResr.StartDate)) then begin
       AddCalcResToAvSalCalc(tEPCalcResr,EPContractr,EPSetBl,monthcount,dateto,dateto2,saltot,daytot,hourtot,repf,readf,hourf,exclper,checkmonthf,a_saltot,a_objtot);
    end else begin
      RecordClear(EPCalcResr);
      ResetLoop(EPCalcResr);
      EPCalcResr.StartDate = exclper;
      EPCalcResr.ContractNr = EPContractr.ContractNr;
      Trhs = true;
      if (ReadFirstKey("StartDate",EPCalcResr,2,Trhs)) begin
          AddCalcResToAvSalCalc(EPCalcResr,EPContractr,EPSetBl,monthcount,dateto,dateto2,saltot,daytot,hourtot,repf,readf,hourf,exclper,checkmonthf,a_saltot,a_objtot);
      end;
    end;
  end;

  return;
end;

function val GetConstantOnDate(string code,date sd,date ed,var string name)
begin
  val res;
  Record EPConstBlock EPConstr;
  row EPConstBlock EPConstrw;
  boolean testf;
  integer rw,rwc;
  
  blockload(EPConstr);
  rwc=MatRowCnt(EPConstr);
  for (rw=0;rw<rwc;rw=rw+1) begin
    MatRowGet(EPConstr,rw,EPConstrw);
    testf = true;
    if (EPConstrw.SDate>sd) then begin
      testf = false;
    end;
    if (EPConstrw.EDate<ed and nonblank(EPConstrw.EDate)) then begin
      testf = false;
    end;
    if (EPConstrw.Code!=code) then begin
      testf = false;
    end;
    if (testf) then begin
      res = EPConstrw.Sum;
      name = EPConstrw.Comment;
      rw = rwc;
    end;
  end;

  GetConstantOnDate = res;
  return;
end;

procedure AddExtraVacation(record EPContractVc EPContractr,record EPPayrollSetBlock EPSetBl,Date dateto,Date dateto2,var val saltot,var val daytot,var val hourtot,Boolean repf,Boolean readf,Boolean ratef,Date exclper,Boolean checkmonthf,var array val a_saltot,var array string a_objtot,var Boolean refreshf,record EPCalcResVc EPCalcResr)
begin
  Date sd,ed,tsd;
  Integer daycnt;
  val tval;
  Integer i;
  string 20 timecl;
  string 255 tstr;
  Integer months;
  
  
  if (EPSetBl.VacCheckOldPer==1) then begin
    tsd = LongOffWorkStarted2(EPContractr.ContractNr,addday(dateto2,-getday(dateto2)+1));
    if (nonblankdate(tsd)) then begin
      months = MonthDiff(tsd,dateto2) + EPSetBl.MonthCount - 1;
    end else begin
      months = EPSetBl.MonthCount*2;
    end;
  GetEPAvSalaryFind(EPContractr,EPSetBl,months,dateto,dateto2,saltot,daytot,hourtot,repf,readf,ratef,exclper,checkmonthf,a_saltot,a_objtot,refreshf,EPCalcResr);
  end;
  
  return;
end;

procedure CheckMinSalary(record EPContractVc EPContractr,record EPPayrollSetBlock EPSetBl,Date dateto,Date dateto2,var val saltot,var val daytot,var val hourtot,var Boolean changef,Boolean hourf,var string minstr)
begin
  string 255 timecl;
  Date sd,ed;
  string 255 tstr;
  val tval;
  Integer daycnt,hourcnt;

  if (EPSetBl.VacAddMinAmount==1) then begin
    if (EPContractr.TimeClass != "") then begin
      timecl = EPContractr.TimeClass; 
    end else begin
      timecl = EPSetBl.DefTimeClass; 
    end;
    sd = addDay(dateto,1);//AddDay(AddMonth(dateto,-EPSetBl.MonthCount),1);
    ed = AddDay(AddMonth(sd,1),-1);
    tval = GetConstantOnDate(EPSetBl.VacAddMinConst,sd,ed,tstr);
    daycnt = amountofworkdays(sd,ed,false,timecl);
    hourcnt = amountofworkhours(EPContractr.ContractNr,sd,ed,true,timecl,true);
    if ((hourf and tval/hourcnt>saltot/hourtot) or (!hourf and tval/daycnt>saltot/daytot)) then begin
      saltot = tval;
      daytot = daycnt;
      hourtot = hourcnt;
      changef = true;
      if (hourf) then begin
        minstr = tval & "/" & hourcnt & "=" & round(saltot/hourtot,SetRoundModeD(2));
      end else begin
        minstr = tval & "/" & daycnt & "=" & round(saltot/daytot,SetRoundModeD(2));
      end;
    end;
  end;
  
  return;
end;

global
function val GetEPAvSalary3(record EPCalcResVc tEPCalcResr,string empcode,date dateto2,string contractnr,date exclper,val curmv,val curmd,boolean addf,val curmd2,boolean repf,var Boolean hourf,var val hours,var array val a_saltot,var array string a_objtot,Boolean usehoursf,var Boolean refreshf)
begin
  record EPCalcResVc EPCalcresr;
  record EPInitAmountsVc EPInitr;
  record EPPayrollSetBlock EPSetBl;
  record EPContractVc EPContractr;
  row EPInitAmountsVc EPInitrw;
  val cval,cdays;
  integer rw,rwc,i;
  date datefrom,dateto;
  val res,fres;
  val daytot,saltot,t,t2;
  boolean TrHs;
  boolean testf,readf,changef;
  string 20 tmp;
  val hourtot,msal,origst,origd;
  string 255 minstr;

  res= 0;
  BlockLoad(EPsetbl);
  saltot = 0;
  daytot = 0;
  dateto = addday(dateto2,-GetDay(dateto2));
  if (EPSetbl.MonthCount>0) then begin
    EPContractr.ContractNr = contractnr;
    readf = true;
    hourf = false;
    if (ReadFirstMain(EPContractr,1,true)) then begin
      if (EPContractr.SubContractf==1) then begin readf = false; end;
      if (usehoursf) then begin
        if (EPSetBl.HourlyRateFlag==1 or EPContractr.HourlyRateFlag==1) then begin
          hourf = true;
        end;
      end;
    end;
    GetEPAvSalaryFind(EPContractr,EPSetBl,EPSetBl.MonthCount,dateto,dateto2,saltot,daytot,hourtot,false,readf,hourf,exclper,false,a_saltot,a_objtot,refreshf,tEPCalcResr);  
    
    if (saltot==0) then begin
      saltot = 0;
      daytot = 0;
      hourtot = 0;
      ClearArray(a_saltot);
      ClearArray(a_objtot);
      AddExtraVacation(EPContractr,EPSetBl,dateto,dateto2,saltot,daytot,hourtot,repf,readf,hourf,exclper,true,a_saltot,a_objtot,refreshf,tEPCalcResr);
    end else begin
      saltot = 0;
      daytot = 0;
      hourtot = 0;
      ClearArray(a_saltot);
      ClearArray(a_objtot);
      GetEPAvSalaryFind(EPContractr,EPSetBl,EPSetBl.MonthCount,dateto,dateto2,saltot,daytot,hourtot,repf,readf,hourf,exclper,false,a_saltot,a_objtot,refreshf,tEPCalcResr);      
    end;
  end;
  
  if (saltot==0) then begin//ja darbinieks strada pirmo menesi, tad nemam no tekosa aprekina
    if (EPContractr.StartDate>=tEPCalcResr.StartDate and EPContractr.StartDate<tEPCalcResr.EndDate) then begin
      if (EPSetBl.ObjectsAvSalary==1) then begin
        ClearArray(a_saltot);
        ClearArray(a_objtot);
        GetMonthSalaryWithObjects(tEPCalcResr,a_saltot,a_objtot);
        for (i=0;i<a_saltot.length;i=i+1) begin
//          AddValObjectToArray(a_saltot,a_objtot,a_sal[i],a_obj[i]);
          daytot = GetAvSalDays(tEPCalcResr,0);
          hourtot = GetAvSalHours(tEPCalcResr,EPSetbl);
          saltot = saltot + a_saltot[i];
          if (repf) then begin
            StartFormat(15);
            if (i==0) then begin
              OutString(20,0,UsetStr(1525117),false);
              OutString(110,"DblCalcRes",tEPCalcResr.SerNr,false);
            end else begin
              ShowWhiteSpace(2);
            end;
            OutString(180,0,tEPCalcResr.StartDate,false);
            OutString(230,0,tEPCalcResr.EndDate,false);
            OutString(270,0,a_objtot[i],false);
            OutString(340,0,a_saltot[i],true);
            OutSTring(400,0,daytot,true);
            if (hourf) then begin
              OutSTring(460,0,hourtot,true);
            end;
            EndFormat;
          end;          
        end;
      end else begin
        saltot = GetMonthAvaregeSalaryCalc(tEPCalcResr);
        daytot = GetAvSalDays(tEPCalcResr,0);
        hourtot = GetAvSalHours(tEPCalcResr,EPSetbl);
 
        StartFormat(15);
        OutString(20,0,UsetStr(1525117),false);
        OutString(110,0,"",false);
        OutString(180,0,tEPCalcResr.StartDate,false);
        OutString(230,0,tEPCalcResr.EndDate,false);
        OutString(340,0,saltot,true);
        OutSTring(400,0,daytot,true);
        if (hourf) then begin
          OutSTring(460,0,hourtot,true);
        end;
        EndFormat;
      end; 
    end;
  end;
  
  if (addf) then begin
    saltot = saltot + curmv;
    daytot = daytot + curmd; 
  end;
  
  if (repf) then begin
    if (hourf) then begin
      Gray_divider(300,460);
    end else begin
      Gray_divider(300,400);
    end;
    StartFormat(15);
    if (EPSetBl.ObjectsAvSalary) then begin
      for (i=0;i<a_saltot.length;i=i+1) begin
        ShowWhiteSpace(2);
        OutString(200,0,a_objtot[i],false);
        OutString(340,0,a_saltot[i],true);
        OutSTring(400,0,daytot,true);
        OutSTring(460,0,round(a_saltot[i]/daytot,SetRoundModeD(2)),true);
      end;
    end else begin
      OutString(200,0,UsetStr(1525130),false);
      OutString(340,0,saltot,true);
      OutSTring(400,0,daytot,true);
      if (hourf) then begin
        OutSTring(460,0,hourtot,true);
      end;
    end;
    EndFormat;
  end;
//  res = round(saltot/daytot,SetRoundModeD(2));
  
  origst = saltot;
  origd = daytot;
  hours = hourtot;
  CheckMinSalary(EPContractr,EPSetBl,dateto,dateto2,saltot,daytot,hourtot,changef,hourf,minstr);
  if (hourf) then begin
    res = round(saltot/hours,SetRoundModeD(2));
  end else begin
    res = round(saltot/daytot,SetRoundModeD(2));
  end;
  if (blank(res)) then begin
    res = 0;
  end;
  
  for (i=0;i<a_saltot.length;i=i+1) begin
    if (hourf) then begin
      a_saltot[i] = a_saltot[i]/hours;    
    end else begin
      a_saltot[i] = a_saltot[i]/daytot;
    end;
  end;
  
  if (repf and changef) then begin
    fres = origst/origd;
    if (blank(fres)) then begin
      fres = 0;
    end;
    StartFormat(15);
    OutString(200,0,UsetStr(1500001),false);
    OutString(430,0,origst & "/" & ValtoString(origd,M4Val,"",".",1) & "=" & fres,true);
    EndFormat;
    StartFormat(15);
    OutString(200,0,UsetStr(1500002),false);
    OutString(430,0,minstr,true);
    EndFormat;
  end;

  if (EPSetBl.AvSalCheckFlag==1) then begin
    EPContractr.ContractNr = contractnr;
    if (ReadFirstMain(EPContractr,1,true)) then begin
      GetContractBase(EPContractr,EPSetBl,cval,tEPCalcResr.StartDate,tEPCalcResr.EndDate)
      cdays = GetAvSalDays(tEPCalcResr,0);
      if (cval/cdays > res) then begin
        if (repf) then begin
          StartFormat(15);
          OutString(20,0,UsetStr(1525119),false);
          OutString(240,0,res,true);
          OutSTring(300,0,round(cval/cdays,SetRoundModeD(2)),true);
          EndFormat;
        end;
        res = round(cval/cdays,SetRoundModeD(2));
      end;
    end;
  end;

  GetEPAvSalary3 = res;
return;
end;

global
function val GetEPAvSalary2(record EPCalcResVc tEPCalcResr,string empcode,date dateto2,string contractnr,date exclper,val curmv,val curmd,boolean addf,val curmd2,boolean repf,var Boolean hourf,var val hours,var array val a_saltot,var array string a_objtot)
begin
  Boolean refreshf;

  GetEPAvSalary2 = GetEPAvSalary3(tEPCalcResr,empcode,dateto2,contractnr,exclper,curmv,curmd,addf,curmd2,repf,hourf,hours,a_saltot,a_objtot,true,refreshf);

return;
end;


global
function val GetEPAvSalary(record EPCalcResVc tEPCalcResr,string empcode,date dateto2,string contractnr,date exclper,val curmv,val curmd,boolean addf,val curmd2,boolean repf)
begin
  Boolean hourf;
  val hours;
  array val a_sal;
  array string 255 a_obj;

  GetEPAvSalary = GetEPAvSalary2(tEPCalcResr,empcode,dateto2,contractnr,exclper,curmv,curmd,addf,curmd2,repf,hourf,hours,a_sal,a_obj);
return;
end;


global
procedure FindCalcResAvSal(string func,record EPCalcresVc EPcalcr,var string source,var string newstr,val dayamount)
begin
  string 100 fname,tstr;
  string 100 fieldname,parname;
  integer i,l,start,startpar;
  boolean openf;  
startLoop:;
  l = len(source);
  fname = func & "(";
  openf = false;
  for (i=0;i<l;i=i+1) begin
    if (mid(source,i,len(fname))==fname) then begin
      openf = true;
      start = i;
      i = i + len(fname);
      startpar = i;
    end;
    if(openf) then begin
      if (mid(source,i,1)==")") then begin
        parname = mid(source,startpar,i - startpar);        
        tstr = valtostring(dayamount,M4Val,"",".",0);
        newstr = left(source,start) & tstr & right(source,l - i - 1);        
        openf = false;
        source = newstr;
        goto startloop;
      end;
    end;
  end;
return;
end;

global
procedure CalcResSetAv(row TaxRepVc TaxReprw,record SMVc vararray,record EPCalcresVc EPcalcr,var string source,var string newstr,val olddayamount,var val dayamount)
begin
  string 255 fname,tstr;
  string 100 fieldname,parname,tempa;
  integer i,l,start,startpar;
  integer tcnt;
  boolean openf;  
  l = len(source);
  fname = "SETAVSAL(";
  openf = false;
  tcnt= 0;
  for (i=0;i<l;i=i+1) begin
    if (mid(source,i,len(fname))==fname) then begin
      openf = true;
      start = i;
      i = i + len(fname);
      startpar = i;
    end;
    if(openf) then begin
      if (mid(source,i,1)=="(") then begin
        tcnt = tcnt +1;
      end;
      if (mid(source,i,1)==")") then begin
        tcnt = tcnt -1;
      end;      
      if (mid(source,i,1)==")" and tcnt == -1) then begin
        parname = mid(source,startpar,i - startpar);        
        tstr = parname;
        FindCalcResAvSal("AVSAL",EPCalcr,tstr,tstr,olddayamount);
        tempa = FCALCWITHVARPay(tstr,vararray,"");  
        dayamount = stringtoval(tempa,M4Val);
        openf = false;
      end;
    end;
  end;
return;
end;

procedure AddTSItem(record EPTSVc EPTSr,integer rownr,var array string trtypes,var array val vals,var array string docnrs,array integer doctypes,var integer size)
begin
  row EPTSVc EPTSrw;
  string 255 objstr;
  string 20 tdocnr;
  integer i;
  MatRowGet(EPTSr,rownr,EPTSrw);
  if (EPTSrw.ObjectsRow<>"") then begin
    objstr = EPTSrw.ObjectsRow;
  end;
  tdocnr = EPTSr.SerNr;
  if (EPTSR.Objects<>"") then begin
    if (objstr <>"") then begin
      objstr = Objstr & ",";
    end;
    objstr = objstr & EPTsr.Objects;
  end;
  
  if (EPTSrw.TrType!="") then begin
    for (i=0;i<size;i=i+1) begin
      if (trtypes[i]== EPTSrw.TrType & ":" & objstr and tdocnr==docnrs[i]) then begin
        vals[i] = vals[i] + EPTSrw.Sum;
        goto LExitL;
      end;
    end;
    docnrs[size] = tdocnr;
    doctypes[size] = 5;
    trtypes[size] = EPTSrw.TrType & ":" & objstr;
    vals[size] = EPTSrw.Sum;
    size = size + 1;
LExitL:
  end;

  if (EPTSrw.TimeTrType!="") then begin
    for (i=0;i<size;i=i+1) begin
      if (trtypes[i]==EPTSrw.TimeTrType & ":" & objstr and tdocnr==docnrs[i]) then begin
        vals[i] = vals[i] + EPTSrw.Qty;
        goto LExitL2;
      end;
    end;
    docnrs[size] = tdocnr;
    trtypes[size] = EPTSrw.TimeTrType & ":" & objstr;
    doctypes[size] = 5;
    vals[size] = EPTSrw.Qty;
    size = size + 1;
LExitL2:
  end;
return;
end;


procedure AddTS2Item(record EPTS2Vc EPTS2r,integer rownr,var array string trtypes,var array val vals,var array string docnrs,array integer doctypes,var integer size,val qty,val sum)
begin
  row EPTS2Vc EPTS2rw;
  string 255 objstr;
  string 20 tdocnr;
  integer i;
  MatRowGet(EPTS2r,rownr,EPTS2rw);
  if (EPTS2rw.ObjectsRow<>"") then begin
    objstr = EPTS2rw.ObjectsRow;
  end;
  tdocnr = EPTS2r.SerNr;
  if (EPTS2r.Objects<>"") then begin
    if (objstr<>"") then begin
      objstr = Objstr & ",";
    end;
    objstr = objstr & EPTs2r.Objects;
  end;
  if (EPTS2rw.TrType!="") then begin
    for (i = 0; i < size ; i = i + 1) begin
      if (trtypes[i]==EPTS2rw.TrType & ":" & objstr and tdocnr==docnrs[i]) then begin
        vals[i] = vals[i] + sum;
        goto LExitL;
      end;
    end;
    docnrs[size] = tdocnr;
    trtypes[size] = EPTS2rw.TrType & ":" & objstr;
    doctypes[size] = 8;
    vals[size] = sum;
    size = size + 1;
LExitL:
  end;

  if (EPTS2rw.TimeTrType!="") then begin
    for (i=0;i<size; i=i+1) begin
      if (trtypes[i]==EPTS2rw.TimeTrType & ":" & objstr and tdocnr==docnrs[i]) then begin
        vals[i] = vals[i] + qty;
        goto LExitL2;
      end;
    end;
    docnrs[size] = tdocnr;
    trtypes[size] = EPTS2rw.TimeTrType & ":" & objstr;
    doctypes[size] = 8;
    vals[size] = Qty;
    size = size + 1;
LExitL2:
  end;
return;
end;

global 
procedure GetTSRec(var record EPCalcResVc EPCalcr,var array string trtypes,var array val vals,var array string docnrs,var array integer doctypes,var integer size)
begin
  record EPTSVc EPTSr;
  record EPTS2Vc EPTS2r;
  row EPTSVc EPTSrw;
  row EPTS2Vc EPTS2rw;
  string 20 contrnr;
  integer rw,rwc,j,k,i;
  boolean TrHs,testf;
  val res;
  val qty,sum;
  EPTSr.StartDate = AddDay(EPCalcR.StartDate,-getDay(EPCalcR.StartDate)+1);
  TrHs =true;
  while (LoopKey("StartDate",EPTSr,1,TrHs)) begin
    testf = true;
    if (EPTSr.StartDate>EPCalcr.EndDate) then begin
      TrHs = false;
    end;
    if (EPTSr.EndDate<EPCalcr.StartDate) then begin
      TrHs = false;
    end;
    if (nonblank(EPTSr.ContractNr) and EPTSr.ContractNr!=EPCalcr.ContractNr) then begin
      testf = false;
    end;
    if (EPTSr.OKFlag==0) then begin
      testf = false;
    end;
    if (TrHs and testf) begin
      contrnr = EPTSr.ContractNr;
      rwc = MatRowCnt(EPTSr);
      for (rw=0;rw<rwc;rw=rw+1) begin
        MatRowGet(EPTSr,rw,EPTSrw);
        if ((EPTSrw.ContractNrRow!="" and EPCalcr.ContractNr==EPTSrw.ContractNrRow) or (EPTsrw.ContractNrRow=="" and EPTSr.ContractNr!="" and EPTSr.ContractNr==EPCalcr.ContractNr)) then begin
          AddTSItem(EPTSr,rw,trtypes,vals,docnrs,doctypes,size);
        end;
      end;
    end;
  end;

//=========
//==adding reords from new register
//=========
  EPTS2r.StartDate = AddDay(EPCalcr.StartDate,-getDay(EPCalcr.StartDate)+1);
  TrHs = true;
  while (LoopKey("ContractNr:" & EPCalcR.ContractNr,EPTS2r,1,TrHs)) begin
    if (EPTS2r.StartDate>EPCalcr.EndDate) then begin
      TrHs = false;
    end else begin
      testf = true;
      if (EPTS2r.OKFlag==0) then begin
        testf = false;
      end;
      if (testf) then begin
        rwc = MatRowCnt(EPTS2r);
        for (rw=0;rw<rwc;rw=rw+1) begin
          MatRowGet(EPTs2r,rw,EPTS2rw);
          testf =true;
          if (EPTS2rw.ContractNr<>EPCalcr.ContractNr) then begin
            testf = false;
          end;
          if (testf) then begin
            if (EPTS2r.StartDate<EPCalcr.StartDate) then begin
              j = GetDay(EPCalcr.StartDate);
            end else begin
              j = GetDay(EPTS2r.StartDate);
            end;
            if (EPTS2r.EndDate>EPCalcr.EndDate) then begin
              k = GetDay(EPCalcr.EndDate);
            end else begin
              k = GetDay(EPTS2r.EndDate);
            end;
            Sum = 0;
            Qty = 0;
            
            for (i=j;i<=k;i=i+1) begin
              res = StringToVal(GetFieldValueByName(EPTS2r,"Day" & i,rw),M4Val);
              if (res==-1) then begin res = 0; end;
              sum = sum + EPTS2rw.Price * res;
              qty = qty + res;
            end;
            if (sum>0 or qty>0) then begin          
              AddTS2Item(EPTS2r,rw,trtypes,vals,docnrs,doctypes,size,qty,sum);
            end;
          end;
        end;
      end;
    end;
  end;
return;
end;

procedure GetAccTrType(string trtype,date cd,string contractnr,var val sum)
begin
  record EPCalcResVc EPCalcr2;
  row EPCalcResVc EPCalcrw;
  integer rwc,rw;
  boolean TrHs,testf;
  
  EPCalcr2.ContractNr = contractnr;
  TrHs = true;
  sum = 0;
  while (LoopBackKey("ContractNr",EPCalcr2,1,TrHs)) begin
    if (EPCalcr2.ContractNr!=contractnr) then begin
      TrHs = false;
    end else begin
      testf = true;   
      //if (DateInRange(cd,EPCalcr2.StartDate,EPCalcr2.EndDate)==false) then begin
      if (GetMonth(EPCalcr2.StartDate)!=GetMonth(cd) or GetYear(EPCalcr2.StartDate)!=GetYear(cd)) then begin
        testf = false;
      end;
      if (testf) then begin
        TrHs = false;
        rwc = MatRowCnt(EPCalcr2);
        for (rw=0;rw<rwc;rw=rw+1) begin
          MatRowGet(EPCalcr2,rw,EPCalcrw);
          if (EPCalcrw.TrType==trtype) then begin
            sum =sum + EPCalcrw.Sum;
          end;
        end;
      end;
    end;
  end;
  return;
end;

global
procedure AccumulatePrevTrTypes(var record EPCalcResVc EPCalcr,record EPContractVc EPContractr)
begin
  record EPTrTypeVc EPTrTyper;
  row EPContractVc EPContractrw;
  row EPCalcResVc EPCalcrw;
  val sum;
  integer rw,rwc;
  integer i,a;
  date cd;
  boolean testf;

  rwc = MatRowCnt(EPContractr);
  for (rw=0;rw<rwc;rw=rw+1) begin
    MatRowGet(EPContractr,rw,EPContractrw);
    if (EPContractrw.Type==0) then begin
      EPTrTyper.Code = EPContractrw.TrType;
      if (Readfirstmain(EPTrTyper,1,true)) then begin
        if (EPTrTyper.GetTrType!="") then begin
          cd = addMonth(EPCalcr.StartDate,-EPTrTyper.Months);
          GetAccTrType(EPtrTyper.GetTrType,cd,EPCalcr.ContractNr,sum);
          EPCalcrw.TrType = EPTrTyper.Code;
          EPCalcrw.Comment = EPTrTyper.Name;
          EPCalcrw.Sum = sum;
          MatRowPut(EPCalcr,MatRowCnt(EPCalcr),EPCalcrw);
        end;
      end;
    end;
  end;

return;
end;


/*
Add/Upd EPCalcResVc row`s with EPBonussVc
comment:
  Check`s every EPBonussVc whose period is EPCalcResVc.StartDate
  EPBonussVc rows must contain same ContractNr and it`s date must be in EPCalcResVc period
to know:
  one row on combination EPBonussVc row TrType and EPBonussVc Objects
*/

global
procedure EPCalcBonussAmount(var record EPCalcResVc EPCalcresr,record EPEntrySetBlock EPEntrySetBl,row EPEntryVc EPEntryrw)
begin
  string 20 tnr;
  record EPBonussVc EPBonussr;
  row EPBonussvc EPBonussrw;
  row EPCalcResVc EPCalcresrw;
  integer i,rwc,rwc2,i2;
  boolean wEPBonussr,FoundRowInEPCalcRes,testf;
  record EPTrTypeVc EPTrTyper;
  string 255 objstr;

  FoundRowInEPCalcRes = false;
  wEPBonussr = true;
  //process every EPBonussVc whose period is EPCalcResVc.StartDate
  //start from first day in month because an employe contract is from x day but EPBonussVc from 01
  EPBonussr.StartDate = AddYear(AddDay(EPCalcresr.StartDate,-GetDay(EPCalcresr.StartDate)+1),-1);
  while (LoopKey("StartDate",EPBonussr,1,wEPBonussr)) begin
    //check if EPCalcResVc.StartDate in EPBonussVc period, if not out of loop
    if (EPCalcResr.StartDate<EPBonussr.StartDate and EPCalcResr.StartDate>EPBonussr.EndDate) then begin
      wEPBonussr = false;
    end else begin
      testf = true;
      if (EPBonussr.OKFlag==0) then begin
        testf = false;
      end;
      if (dateinrange(EPCalcResr.StartDate,EPBonussr.StartDate,EPBonussr.EndDate)==false) then begin
        testf = false;
      end;
      if (testf) then begin
        tnr = EPBonussr.SerNr;
        rwc = MatRowCnt(EPBonussr);
        for(i=0;i<rwc;i=i+1)begin
          MatRowGet(EPBonussr,i,EPBonussrw);
          //check ContractNr and EPBonussVc row Date to be in EPCalcResVc period
          if (EPBonussrw.ContractNr == EPCalcResr.ContractNr 
          and DateInRange(EPBonussrw.Date,EPCalcResr.StartDate,EPCalcResr.EndDate) 
          and EPBonussrw.TrType <>"") then begin
            //look`s for row in EPCalcRes with same TrType and Objects
            objstr = EPBonussrw.Objects;
            if (blank(objstr)) then begin
              objstr = EPBonussr.Objects;
            end;
            rwc2 = MatRowCnt(EPCalcresr);
            FoundRowInEPCalcRes = false;
            for (i2=0;i2<rwc2;i2=i2+1) begin
              MatRowGet(EPCalcresr,i2,EPCalcresrw);
              if (EPCalcresrw.TrType==EPBonussrw.TrType 
              and EPCalcresrw.Objects==objstr 
              and EPCalcResrw.RefDocType==2 
              and EPCalcResrw.RefDocStr==tnr) then begin
                EPCalcresrw.Sum = EPCalcResrw.Sum + EPBonussrw.Sum;
                MatRowPut(EPCalcResr,i2,EPCalcresrw);
                FoundRowInEPCalcRes = true;
                i2 = rwc2;
              end;
            end;
            //if didn`t found row in EPCalcRes with same TrType and Objects, then put`s new in end
            if (!FoundRowInEPCalcRes) then begin
              EPCalcresrw.Sum = EPBonussrw.Sum;
              EPCalcresrw.TrType = EPBonussrw.TrType;
              EPCalcresrw.Objects = objstr;
              EPCalcresrw.Comment = EPBonussrw.Comment;
              EPCalcResrw.RefDocType = 2;
              EPCalcResrw.RefDocStr = EPBonussr.SerNr;
              EPTrTyper.Code = EPBonussrw.TrType;
              if (ReadFirstMain(EPTrTyper,1,True)) Then Begin
                EPCalcResrw.IncType = EPTrTyper.IncType;
              end;
              MatRowPut(EPCalcresr,rwc2,EPCalcresrw);
            end;
          end;
        end;
      end;
    end;
  end;
  if (EPEntryrw.ContractNr==EPCalcresr.ContractNr) then begin
    AddEPEntryVal(EPCalcResr,EPEntrySetBl.BonTrType1,EPEntryrw.Bonuss1,EPEntryrw.ManBonuss1f);
    AddEPEntryVal(EPCalcResr,EPEntrySetBl.BonTrType2,EPEntryrw.Bonuss2,EPEntryrw.ManBonuss2f);
    AddEPEntryVal(EPCalcResr,EPEntrySetBl.BonTrType3,EPEntryrw.Bonuss3,EPEntryrw.ManBonuss3f);
  end;
  return;
end;


global 
procedure GetPeriodDayCount(var integer curday,date datefrom,integer daysbefore,date offenddate,date paystartdate,date payenddate,integer dayscount,var longint offworkdays,var integer calcorr,string timecl,record EPOffWorkGroupVc EPOffgrr,record EPOffTrTypeVc EPOffTrTyper)
begin
  record BHollVc BHr;
  record TimeClassVc TimeClr;
  record CYBlock CYbl;
  date tempdate,ed;
  integer i,curday2;
  boolean testf;
  blockload(CYbl);
  i = 0;
  BHr.CountryCode = CYbl.CountryCode;
  testf = ReadFirstMain(BHr,1,true);
  TimeClr.Code = timecl;
  testf = ReadFirstMain(Timeclr,1,true);
  tempdate = addday(datefrom,curday);
  ed = payenddate;
  if (EPOffTrTyper.PayType==0) then begin
    if (offenddate > payenddate) then begin
      ed = offenddate;
    end;
  end else begin
    if (offenddate<payenddate) then begin
      ed = offenddate;
    end;
  end;
  i = 0;
  tempdate = addday(datefrom,curday);
  if (tempdate<paystartdate) then begin
    tempdate = paystartdate;
  end;
  while ((tempdate<=offenddate and tempdate<=payenddate) and i<=dayscount) begin
    if ((IsEPHolliday(tempdate,BHr,Timeclr,false,false)==false and testf) or testf==false) or EPOffgrr.IncHol == 1 or EPOffgrr.IncFree==1 then begin
      if (EPOffgrr.SubWorkDays==1) then begin
        offworkdays = offworkdays + 1;
      end;
    end;
    i = i + 1;
    curday = curday + 1;
    tempdate = addday(datefrom,curday);
    if (EPOffgrr.SubCalDays==1) then begin
      calcorr = calcorr + 1;
    end;
  end;

return;
end;



global
procedure GetEmpTaxGroup(string empcode,date td,var string taxgroup)
begin
  record EPEmpVc EPEmpr;
  record EPOrdStatChVc EPordr;
  boolean Trhs,testf;

  EPEmpr.EmpCode = empcode;
  if (ReadFirstMain(EPEmpr,1,true)) then begin
    taxgroup=EPEmpr.TaxGroup;
  end;
  EPOrdr.StartDate = CurrentDate;
  EPOrdr.EmpCode = empcode;
  trhs = true;
  while (loopBackKey("EmpDate",EPOrdr,2,TrHs)) begin
    testf = true;
    if (EPOrdr.EmpCode<>empcode) then begin
      TrhS = false;
      testf = false;
    end;
    if (EPOrdr.StartDate>td) then begin
      testf = false;
    end;
    if (testf) then begin
      taxgroup = EPOrdr.TaxGroup;
      TrHs = false;
    end;
  end;
return;
end;

function val GetTrTypeVal(record EPCalcResVc EPCalcResr,string trtype)
begin
  row EPCalcResVc EPCalcResrw;

  val res;
  integer rw,rwc;
  if (nonblank(trtype)) then begin
    rwc = MatRowCnt(EPCalcResr);
    for (rw=0;rw<rwc;rw=rw+1) begin
      MatRowGet(EPCalcResr,rw,EPCalcResrw);
      if (EPCalcresrw.TrType==TrType) then begin res = res + EPCalcResrw.Sum; end;
    end;
  end;
  GetTrTypeVal = res;
return;
end;

global
procedure UpdateUserFields(var record EPCalcResVc EPCalcResr)
begin
  record EPPayrollSetBlock EPPaybl;
  blockload(EPPaybl);
  EPCalcResr.UserVal0 = GetTrTypeVal(EPCalcResr,EPPaybl.FieldTrType0);
  EPCalcResr.UserVal1 = GetTrTypeVal(EPCalcResr,EPPaybl.FieldTrType1);
  EPCalcResr.UserVal2 = GetTrTypeVal(EPCalcResr,EPPaybl.FieldTrType2);
  EPCalcResr.UserVal3 = GetTrTypeVal(EPCalcResr,EPPaybl.FieldTrType3);
  EPCalcResr.UserVal4 = GetTrTypeVal(EPCalcResr,EPPaybl.FieldTrType4);
  EPCalcResr.UserVal5 = GetTrTypeVal(EPCalcResr,EPPaybl.FieldTrType5);
  EPCalcResr.UserVal6 = GetTrTypeVal(EPCalcResr,EPPaybl.FieldTrType6);
  EPCalcResr.UserVal7 = GetTrTypeVal(EPCalcResr,EPPaybl.FieldTrType7);
  EPCalcResr.UserVal8 = GetTrTypeVal(EPCalcResr,EPPaybl.FieldTrType8);
  EPCalcResr.UserVal9 = GetTrTypeVal(EPCalcResr,EPPaybl.FieldTrType9);
  
return;
end;


procedure EPCalcPutDayVal(var record EPCalcResVc EPCalcResr,record EPPayrollSetBlock EPPaySetbl,string code,val days)
begin

  if (code==EPPaySetbl.DayField0) then begin EPCalcResr.UserDays0 = days; end;
  if (code==EPPaySetbl.DayField1) then begin EPCalcResr.UserDays1 = days; end;
  if (code==EPPaySetbl.DayField2) then begin EPCalcResr.UserDays2 = days; end;
  if (code==EPPaySetbl.DayField3) then begin EPCalcResr.UserDays3 = days; end;
  if (code==EPPaySetbl.DayField4) then begin EPCalcResr.UserDays4 = days; end;
  if (code==EPPaySetbl.DayField5) then begin EPCalcResr.UserDays5 = days; end;
  if (code==EPPaySetbl.DayField6) then begin EPCalcResr.UserDays6 = days; end;
  if (code==EPPaySetbl.DayField7) then begin EPCalcResr.UserDays7 = days; end;
  if (code==EPPaySetbl.DayField8) then begin EPCalcResr.UserDays8 = days; end;
  
return;
end;

global
procedure OutDayAr(array integer arDayPer,integer size,date sd,date ed)
begin
  integer i,l,offset;
  
  l = DateDiff(ed,sd)+1;
  offset = DateDiff(sd,"01.01.1990");
  LogText(0,"--------");
  for (i=0;i<l;i=i+1) begin
    LogText(0,DateToString(AddDay(sd,i),"DD.MM.YYYY") & " - " & offset + i & " " & arDayPer[offset+i]);
  end;
  LogText(0,"--------");

return;
end;


global
function longint GetExcludedDays(array integer arDayPer,date sd,date ed,integer type)
begin
  longint res;
  integer i,l,offset;
  l = DateDiff(ed,sd)+1;
  offset = DateDiff(sd,"01.01.1990");
  res = 0;
  for (i=0;i<l;i=i+1) begin
    if (type==0) then begin
      if (arDayPer[offset+i]==-3) then begin
        res = res + 1;
      end;
    end;
  end;
  
GetExcludedDays = res;
return;
end;

global
procedure UpdateDayPerAr(var array integer arDayPer,var integer size,date d1,date d2,string timecl,integer daytype,integer type)
begin
  record BHollVc BHr;
  record TimeClassVc Timeclr;
  record CYBlock CYbl;
  longint i,l,offset;
  integer addval;
  date tempdate;
  boolean testf;
  array val arrhours;
  blockload(CYbl);
  /*
  description of day array values
  > 0 - hours worked
  -1 - holiday
  -2 - calendar day, should be counted in totals
  -3 - offworks
  -4 - exclude from calculations
  -99 - no changes needed
  */
  BHr.CountryCode = CYbl.CountryCode;
  testf = ReadFirstMain(BHr,1,true);
  Timeclr.Code = timecl;
  testf = ReadFirstMain(Timeclr,1,true);

  l = DateDiff(d2,d1)+1;
  offset = DateDiff(d1,"01.01.1990");
  for (i=0;i<l;i=i+1) begin
      tempdate = AddDay(d1,i);
      addval = -99;
      if (daytype==0) then begin
        if (IsEPHolliday(tempdate,BHr,Timeclr,false,false)==false) then begin
          switch type begin
            case 0: addval = GetHour(TimeDiff(TimeClr.StartTime,TimeClr.EndTime));
            case 1: addval = -3;
            case 2: addval = -4;
          end;
        end;
      end;
      if (daytype==1) then begin
        switch type begin
          case 0: addval = -2;
          case 1: addval = -3;
          case 2: addval = -4;
        end;
      end;
      if (daytype==2) then begin
        if (IsEPHolliday(tempdate,BHr,Timeclr,false,false)==true) then begin
          switch type begin
            case 0: addval = -1;
            case 1: addval = -3;
            case 2: addval = -4;
          end;
        end;
      end;
      if (addval<>-99) then begin
        arDayPer[offset + i] = addval;
        if (addval==-3) then begin
          //Logtext(0,offset + i & "  " & arDayPer[offset + i]);
        end;
      end;
  end;
  return;
end;

global
procedure CalcUserDays(record EPCalcResVc EPCalcResr,record EPCalcDaysVc EPCalcDayr,string timecl,var val days,var date d1,var date d2,array integer arDayPer,var integer size)
begin
  row EPCalcDaysVc EPCalcDayrw;
  row EPCalcResVc EPCalcResrw;
  
  record EPOffWorkVc EPOffWorkr;
  date sd,ed;
  boolean periodf,monthf;
  integer rw,rwc;
  integer rw2,rwc2;
  integer res;
  integer i;
  boolean Trhs,testf,dayf;

  d1 = "";
  d2 = "";
  rwc = MatRowCnt(EPCalcDayr);
  for (rw = 0; rw <rwc;rw = rw +1) begin
    MatRowGet(EPCalcDayr,rw,EPCalcDayrw);
    dayf = true;
    res = 0;
    switch (EPCalcDayrw.ActionType) begin
      case 0:
              if (EPCalcDayrw.DayType==3) then begin      
                rwc2 = MatRowCnt(EPCalcResr);               
                for (rw2=0;rw2<rwc2;rw2=rw2+1) begin
                  MatRowGet(EPCalcResr,rw2,EPCalcResrw);
                  if (EPCalcDayrw.OffWorkGroup==EPCalcResrw.TrType) then begin
                    days = days + EPCalcResrw.Sum;
                  end;
                end;       
              end;
              dayf = false;
            
      case 1: 
              sd = EPCalcResr.StartDate; 
              ed = EPCalcResr.EndDate;
              UpdateDayPerAr(arDayPer,size,sd,ed,timecl,EPCalcDayrw.DayType,0);
              periodf = true;

      case 2: 
              sd = AddDay(EPCalcResr.StartDate,-GetDay(EPCalcResr.StartDate)+1);
              ed = AddDay(sd,DaysInMonth(getyear(EPcalcresr.StartDate),Getmonth(EPCalcResr.StartDate))-1);
              UpdateDayPerAr(arDayPer,size,sd,ed,timecl,EPCalcDayrw.DayType,0);
              monthf = true;
      case 3: // include if starts in period
             if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin
               Trhs = true;
               Resetloop(EPOffWorkr);
               EPOffWorkr.ContractNr = EPCalcResr.ContractNr;
               EPOffWorkr.EmpCode = EPCalcResr.EmpCode;
               while LoopKey("EmpCode",EPOffWorkr,1,TrHs) begin
                  testf = true;
                  if (EPoffWorkr.ContractNr <> EPCalcResr.ContractNr) then begin
                    if (not (EPOffWorkr.ContractNr== "" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode)) then begin
                      testf = false;
                    end;
                  end;
                  if (EPOffWorkr.EmpCode <> EPCalcResr.EmpCode) then begin
                  testf = false;
                  trhs = false;
                  end;
                  if (EPOffWorkr.Group<> EPCalcDayrw.OffWorkGroup) then begin
                    testf = false;
                  end;
                  if (EPOffWorkr.OKFlag ==0) then begin
                    testf = false;
                  end;
                  if (testf) then begin
                   // if (EPOffWorkr.StartDate < EPCalcResr.EndDate and EPoffWorkr.EndDate < EPCalcResr.EndDate) then begin
                    if (addday(EPOffWorkr.StartDate,-1) <= EPCalcResr.EndDate and addday(EPOffWorkr.StartDate,-1) > EPCalcResr.StartDate) then begin
                      dayf = false;
                      /*
                      if (Periodf) then begin
                        if (EPOffWorkr.StartDate < EPCalcResr.StartDate) then begin
                          sd = EPOffWorkr.StartDate;
                          ed = AddDay(EPCalcResr.StartDate,-1);
                          dayf = true;
                        end;
                      end else begin
                      */
                        sd = EPOffWorkr.StartDate;
                        ed = EPOffWorkr.EndDate;
                        dayf = true;
                      //end;
                      if (dayf) then begin
                        periodf = true;
                        switch EPCalcDayrw.DayType begin
                          case 0: 
                          res = AmountOfWorkDays(sd,ed,false,timecl);//work days
                          case 1: res = DateDiff(ed,sd)+1;//calendar days
                          case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays
                        end;
                        days = days + res;
                        if (sd < d1 and nonblankDate(d1)) then begin d1 = sd; end;
                        if (blankdate(d1)) then begin d1 = sd; end;
                        if (ed > d2) then begin d2 = ed; end;                        
                      end;
                    end;
                  end;
                end;
              end;
              dayf = false;
      case 4: // include if at ending
             if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin
               Trhs = true;
               Resetloop(EPOffWorkr);
               EPOffWorkr.ContractNr = EPCalcResr.ContractNr;
               EPOffWorkr.EmpCode = EPCalcResr.EmpCode;
               while LoopKey("EmpCode",EPOffWorkr,1,TrHs) begin
                 testf = true;
                 if (EPoffWorkr.ContractNr <> EPCalcResr.ContractNr) then begin
                 if (not (EPOffWorkr.ContractNr== "" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode)) then begin
                   testf = false;
                 end;
               end;
               if (EPOffWorkr.EmpCode <> EPCalcResr.EmpCode) then begin
                 testf = false;
                 trhs = false;
               end;
               if (EPOffWorkr.Group<> EPCalcDayrw.OffWorkGroup) then begin
                 testf = false;
               end;
               if (EPOffWorkr.OKFlag==0) then begin
                 testf = false;
               end;
               if (testf) then begin
                 if (EPOffWorkr.StartDate >= EPCalcResr.StartDate and EPoffWorkr.StartDate <= EPCalcResr.EndDate) then begin
                   dayf = false;
                   if (Periodf) then begin
                     if (EPOffWorkr.EndDate > EPCalcResr.EndDate) then begin
                       sd = AddDay(EPCalcResr.EndDate,1);
                       ed = EPCalcResr.EndDate;
                       dayf = true;
                     end;
                   end else begin
                     sd = EPOffWorkr.StartDate;
                     ed = EPOffWorkr.EndDate;
                     dayf = true;
                   end;
                   if (dayf) then begin
                     switch EPCalcDayrw.DayType begin
                       case 0: 
                       res = AmountOfWorkDays(sd,ed,false,timecl);//work days
                       case 1: res = DateDiff(ed,sd)+1;//calendar days
                       case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays
                     end;
                     days = days + res;
                     if (sd < d1 and nonblankDate(d1)) then begin d1 = sd; end;
                     if (blankdate(d1)) then begin d1 = sd; end;
                     if (ed > d2) then begin d2 = ed; end;
                   end;
                 end;
               end;
             end;
           end;
           dayf = false;
     case 5: // substract if at begining
             if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin
               Trhs = true;
               Resetloop(EPOffWorkr);
               EPOffWorkr.EmpCode = EPCalcResr.EmpCode;
               while LoopKey("EmpCode",EPOffWorkr,1,TrHs) begin
                  testf = true;
                  if (EPoffWorkr.ContractNr <> EPCalcResr.ContractNr) then begin
                    if (not (EPOffWorkr.ContractNr== "" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode)) then begin
                      testf = false;
                    end;
                  end;
                  if (EPOffWorkr.EmpCode <> EPCalcResr.EmpCode) then begin
                    testf = false;
                    trhs = false;
                  end;
                  if (EPOffWorkr.Group<> EPCalcDayrw.OffWorkGroup) then begin
                    testf = false;
                  end;
                  if (EPOffWorkr.OKFlag==0) then begin
                    testf = false;
                  end;
                  if (testf) then begin
                    if (EPOffWorkr.EndDate >= EPCalcResr.StartDate and EPoffWorkr.EndDate <= EPCalcResr.EndDate) then begin
                    
                      if (EPOffWorkr.StartDate < EPCalcResr.StartDate) then begin
                        sd = EPCalcResr.StartDate;
                        ed = EPOffWorkr.EndDate;
                      end else begin
                        sd = EPOffWorkr.StartDate;
                        ed = EPOffWorkr.EndDate;
                      end;
                      switch EPCalcDayrw.DayType begin
                        case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days
                        case 1: res = DateDiff(ed,sd)+1;//calendar days
                        case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays
                      end;
                      days = days - res;
                    end;
                  end;
                end;
              end;
              dayf = false;
     case 6:  //substract if at ending
              if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin
                Trhs = true;
                Resetloop(EPOffWorkr);
                EPOffWorkr.ContractNr = EPCalcResr.ContractNr;
                EPOffWorkr.EmpCode = EPCalcResr.EmpCode;
                while LoopKey("EmpCode",EPOffWorkr,1,TrHs) begin
                  testf = true;
                  if (EPoffWorkr.ContractNr <> EPCalcResr.ContractNr) then begin
                    if (not (EPOffWorkr.ContractNr== "" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode)) then begin
                      testf = false;
                    end;
                  end;
                  if (EPOffWorkr.EmpCode <> EPCalcResr.EmpCode) then begin
                    testf = false;
                    trhs = false;
                  end;
                  if (EPOffWorkr.Group<> EPCalcDayrw.OffWorkGroup) then begin
                    testf = false;
                  end;
                  if (EPOffWorkr.OKFlag==0) then begin
                    testf = false;
                  end;
                  if (testf) then begin
                    if (EPOffWorkr.StartDate >= EPCalcResr.StartDate and EPoffWorkr.StartDate <= EPCalcResr.EndDate) then begin
                      if (EPOffWorkr.EndDate > EPCalcResr.EndDate) then begin
                        sd = EPOffWorkr.StartDate;
                        ed = EPCalcResr.EndDate;
                      end else begin
                        sd = EPOffWorkr.StartDate;
                        ed = EPOffWorkr.EndDate;
                      end;
                      switch EPCalcDayrw.DayType begin
                        case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days
                        case 1: res = DateDiff(ed,sd)+1;//calendar days
                        case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays
                      end;
                      days = days - res;
                    end;
                  end;
                end;
              end;
              dayf = false;
     case 7:  //add always
              if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin
                Trhs = true;
                Resetloop(EPOffWorkr);
                EPOffWorkr.ContractNr = EPCalcResr.ContractNr;
                EPOffWorkr.EmpCode = EPCalcResr.EmpCode;
                while LoopKey("EmpCode",EPOffWorkr,1,TrHs) begin
                  testf = true;
                  if (EPoffWorkr.ContractNr <> EPCalcResr.ContractNr) then begin
                    if (not (EPOffWorkr.ContractNr== "" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode)) then begin
                      testf = false;
                    end;
                  end;
                  if (EPOffWorkr.EmpCode <> EPCalcResr.EmpCode) then begin
                    testf = false;
                    trhs = false;
                  end;
                  if (EPOffWorkr.Group <> EPCalcDayrw.OffWorkGroup) then begin
                    testf = false;
                  end;
                  if (EPOffWorkr.OKFlag==0) then begin
                    testf = false;
                  end;
                  if (testf) then begin
                    if (EPOffWorkr.StartDate <= EPCalcResr.EndDate and EPOffWorkr.EndDate >= EPCalcResr.StartDate) then begin
                      dayf = false;
                      if (periodf) then begin
                        if (EPOffWorkr.StartDate < EPCalcResr.StartDate) then begin
                          sd = EPOffWorkr.StartDate;
                          ed = AddDay(EPCalcResr.StartDate,-1);
                          switch EPCalcDayrw.DayType begin
                            case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days
                            case 1: res = DateDiff(ed,sd)+1;//calendar days
                            case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays
                          end;
                          days = days + res;
                          if (sd < d1 and nonblankDate(d1)) then begin d1 = sd; end;
                          if (blankdate(d1)) then begin d1 = sd; end;
                          if (ed > d2) then begin d2 = ed; end;
                        end;
                        if (EPOffWorkr.EndDate > EPCalcResr.EndDate) then begin
                          sd = AddDay(EPCalcResr.EndDate,1);
                          ed = EPOffWorkr.EndDate;
                          dayf = true;
                        end;
                      end else begin
                        sd = EPOffWorkr.StartDate;
                        ed = EPOffWorkr.EndDate;
                        dayf = true;
                      end;
                      if (dayf) then begin
                        switch EPCalcDayrw.DayType begin
                          case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days
                          case 1: res = DateDiff(ed,sd)+1;//calendar days
                          case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays
                        end;
                        days = days + res;
                        if (sd < d1 and nonblankDate(d1)) then begin d1 = sd; end;
                        if (blankdate(d1)) then begin d1 = sd; end;
                        if (ed > d2) then begin d2 = ed; end;
                      end;
                    end;
                  end;
                end;
              end;
              dayf = false;
   case 8: //substract always
             if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin
               TrHs = true;
               Resetloop(EPOffWorkr);
               EPOffWorkr.ContractNr = EPCalcResr.ContractNr;
               EPOffWorkr.EmpCode = EPCalcResr.EmpCode;
               while LoopKey("EmpCode",EPOffWorkr,1,TrHs) begin
                  testf = true;
                  if (EPoffWorkr.ContractNr <> EPCalcResr.ContractNr) then begin
                    if (not (EPOffWorkr.ContractNr== "" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode)) then begin
                      testf = false;
                    end;
                  end;
                  if (EPOffWorkr.EmpCode <> EPCalcResr.EmpCode) then begin
                    testf = false;
                    trhs = false;
                  end;
                  if (EPOffWorkr.Group <> EPCalcDayrw.OffWorkGroup) then begin
                    testf = false;
                  end;
                  if (EPOffWorkr.OKFlag==0) then begin
                    testf = false;
                  end;
                  if (EPOffWorkr.EndDate < EPCalcResr.StartDate) then begin
                    testf = false;
                  end;
                  if (EPOffWorkr.StartDate > EPCalcResr.EndDate) then begin
                    testf = false;
                  end;
                  if (testf) then begin
                    if (EPOffWorkr.StartDate < EPCalcResr.StartDate) then begin
                      sd = EPCalcResr.StartDate;
                    end else begin
                      sd = EPOffWorkr.StartDate;
                    end;
                    if (EPOffWorkr.EndDate > EPCalcResr.EndDate) then begin
                      ed = EPCalcResr.EndDate;
                    end else begin
                      ed = EPOffWorkr.EndDate;
                    end;
                    switch EPCalcDayrw.DayType begin
                      case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days
                      case 1: res = DateDiff(ed,sd)+1;//calendar days
                      case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays
                    end;
                    UpdateDayPerAr(arDayPer,size,sd,ed,timecl,EPCalcDayrw.DayType,1);
                    days = days - res;
                    if (EPOffWorkr.StartDate <= d1 and ed < d2 and ed > d1 and nonblankDate(d1)) then begin 
                      d1 = addday(ed,1); 
                    end;
                  end;
                end;
              end;
              dayf = false;
      case 9:
             if (nonblank(EPCalcDayrw.OffWorkGroup)) then begin
               TrHs = true;
               Resetloop(EPOffWorkr);
               EPOffWorkr.ContractNr = EPCalcResr.ContractNr;
               EPOffWorkr.EmpCode = EPCalcResr.EmpCode;
               while LoopKey("EmpCode",EPOffWorkr,1,TrHs) begin
                  testf = true;
                  if (EPoffWorkr.ContractNr <> EPCalcResr.ContractNr) then begin
                    if (not (EPOffWorkr.ContractNr== "" and EPOffWorkr.EmpCode==EPCalcResr.EmpCode)) then begin
                      testf = false;
                    end;
                  end;
                  if (EPOffWorkr.EmpCode <> EPCalcResr.EmpCode) then begin
                    testf = false;
                    trhs = false;
                  end;
                  if (EPOffWorkr.Group <> EPCalcDayrw.OffWorkGroup) then begin
                    testf = false;
                  end;
                  if (EPOffWorkr.OKFlag==0) then begin
                    testf = false;
                  end;
                  if (EPOffWorkr.EndDate < EPCalcResr.StartDate) then begin
                    testf = false;
                  end;
                  if (EPOffWorkr.StartDate > EPCalcResr.EndDate) then begin
                    testf = false;
                  end;
                  if (testf) then begin
                    if (EPOffWorkr.StartDate < EPCalcResr.StartDate) then begin
                      sd = EPCalcResr.StartDate;
                    end else begin
                      sd = EPOffWorkr.StartDate;
                    end;
                    if (EPOffWorkr.EndDate > EPCalcResr.EndDate) then begin
                      ed = EPCalcResr.EndDate;
                    end else begin
                      ed = EPOffWorkr.EndDate;
                    end;
                    switch EPCalcDayrw.DayType begin
                      case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days
                      case 1: res = DateDiff(ed,sd)+1;//calendar days
                      case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays
                    end;
                    days = days + res;
                    if (sd < d1 and nonblankDate(d1)) then begin d1 = sd; end;
                    if (blankdate(d1)) then begin d1 = sd; end;
                    if (ed > d2) then begin d2 = ed; end;
                  end;
                end;
              end;
              dayf = false;
      case 10:
      othervise:
        dayf = false;
    end;
    if (dayf) then begin
        switch EPCalcDayrw.DayType begin
          case 0: res = AmountOfWorkDays(sd,ed,false,timecl);//work days
          case 1: res = DateDiff(ed,sd)+1;//calendar days
          case 2: res = AmountOfHoliDays(sd,ed,false,timecl);//holidays
          case 4: res = GetTimeTableDays(sd,ed,EPCalcResr.ContractNr);
        end;
      days = days + res;
      if (sd < d1 and nonblankDate(d1)) then begin d1 = sd; end;
      if (blankdate(d1)) then begin d1 = sd; end;
      if (ed > d2) then begin d2 = ed; end;
    end;
  end;
  
return;
end;

global 
procedure FillCalcDayFields(var record EPCalcResVc EPCalcResr)
begin
  array integer arDayPer;
  integer size;
  record EPPayrollSetBlock EPPaybl;
  record EPContractVc EPContractr;
  record EPCalcDaysVc EPCalcDayr;
  string 20 timecl;
  date d1,d2;
  integer fieldnr;
  boolean testf;
  val days;
  
  blockload(EPPaybl);
  EPContractr.ContractNr = EPCalcResr.ContractNr;
  if (ReadFirstMain(EPContractr,1,true)) then begin
    if (EPContractr.TimeClass<>"") then begin
      timecl = EPContractr.TimeClass;
    end else begin
      timecl = EPPaybl.DefTimeClass;
    end;
    while LoopMain(EPCalcDayr,1,true) begin
      days = 0;
      CalcUserDays(EPCalcResr,EPCalcDayr,timecl,days,d1,d2,arDayPer,size);
      EPCalcPutDayVal(EPCalcResr,EPPaybl,EPCalcDayr.Code,days);
    end;
  end;

return;
end;

global
procedure AddHourlyRate(var record EPCalcResVc EPCalcResr,var record SMVc vararray,var record SMVc vararrayobj)
begin
  record EPTaxesVc EPTaxesr;
  row EPTaxesVc EPTaxesrw;
  string 20 ratecode;
  record EPContractVc EPContractr;
  record EPPayrollSetBlock EPPaySetBl;
  integer rw,rwc;

  BlockLoad(EPPaySetBl);
  if (EPPaySetBl.EmpRateCode <> "") then begin
    EPContractr.ContractNr = EPCalcResr.ContractNr;
    if (ReadFirstMain(EPContractr,1,true)) then begin
      ratecode = EPContractr.TSTaxCode; 
      if (ratecode =="") then begin ratecode = EPPaySetBl.TSTaxCode; end;
    End;

    EPTaxesr.TaxCode = ratecode;
    if (ReadFirstMain(EPTaxesr,1,True)) then begin
      rwc = MatRowCnt(EPTaxesr);
      for (rw = 0; rw < rwc; rw = rw + 1) begin
        MatRowGet(EPTaxesr,rw,EPTaxesrw);
      if (dateinrange(EPCalcResr.StartDate,EPTaxesrw.SDate,EPTaxesrw.EDate)) then begin
          addvarval(EPPaySetBl.EmpRateCode,vararray,EPTaxesrw.Amount); 
          addvarval(EPPaySetBl.EmpRateCode,vararrayobj,EPTaxesrw.Amount);  
        end;
    end;
    end;
  end;
return;
end;

global
procedure AddConstData(var record EPCalcResVc EPCalcResr,var record SMVc vararray,var record SMVc vararrayobj)
begin
  array integer arDayPer;
  integer size;
  
  record EPPayrollSetBlock EPPaybl;
  Record EPConstBlock EPConstr;
  record EPContractVc EPContractr;
  record EPCalcDaysVc EPCalcDayr;
  row EPConstBlock EPConstrw;
  string 20 timecl;
  date d1,d2,sd,ed;
  boolean testf;
  val empdays,perdays;
  val amount;

  integer rw,rwc;
  
  blockload(EPConstr);
  blockload(EPPaybl);
  
  EPContractr.ContractNr = EPCalcResr.ContractNr;
  if (ReadFirstMain(EPContractr,1,true)) then begin
    if (EPContractr.TimeClass<>"") then begin
      timecl = EPContractr.TimeClass;
    end else begin
      timecl = EPPaybl.DefTimeClass;
    end;
    rwc=MatRowCnt(EPConstr);
    for (rw=0;rw<rwc;rw=rw+1) begin
      MatRowGet(EPConstr,rw,EPConstrw);
      testf = true;
      if (EPConstrw.SDate>EPCalcresr.StartDate) then begin
        testf = false;
      end;
      if (EPConstrw.EDate<EPCalcResr.EndDate and nonblank(EPConstrw.EDate)) then begin
        testf = false;
      end;
      if (testf) then begin
        if (blank(EPConstrw.DayCode)) then begin
          addvarval(EPConstrw.Code,vararray,EPConstrw.Sum); 
          addvarval(EPConstrw.Code,vararrayobj,EPConstrw.Sum);  
        end else begin
          EPCalcDayr.Code = EPConstrw.DayCode;
          if (ReadFirstMain(EPCalcDayr,1,true)) then begin   
            empdays = 0;
            CalcUserDays(EPCalcResr,EPCalcDayr,timecl,empdays,d1,d2,arDayPer,size);
            //UpdateDayPerAr(arDayPer,size,sd,ed,timecl,EPCalcDayrw.DayType,0);
            amount = CalcConst(d1,d2,empdays,EPConstrw.Sum,arDayPer);
          end;
          addvarval("#" & EPConstrw.Code,vararray,amount); 
          addvarval("#" & EPConstrw.Code,vararrayobj,amount);  
        end; 
      end;
    end;
  end;
  return;
end;


global
procedure AddEPCalcDays(record EPCalcResVc EPCalcResr,record SMVc vararray,record SMVc vararrayobj, record EPPayrollSetBlock EPPayrollSetr)
begin
  record EPCalcDaysVc EPCalcDaysr;
  integer i;
  
  FillCalcDayFields(EPCalcResr);
  i = 0;
  EPCalcDaysr.Code = EPPayrollSetr.DayField0;
  if (ReadFirstMain(EPCalcDaysr,1,true)) then begin
    addvarval(EPCalcDaysr.CalcStr,vararray,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
    addvarval(EPCalcDaysr.CalcStr,vararrayobj,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
  end;   
  i = i +1;
  EPCalcDaysr.Code =EPPayrollSetr.DayField1;
  if (ReadFirstMain(EPCalcDaysr,1,true)) then begin
    addvarval(EPCalcDaysr.CalcStr,vararray,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
    addvarval(EPCalcDaysr.CalcStr,vararrayobj,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
  end;
  i = i +1;
  EPCalcDaysr.Code =EPPayrollSetr.DayField2;
  if (ReadFirstMain(EPCalcDaysr,1,true)) then begin
    addvarval(EPCalcDaysr.CalcStr,vararray,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
    addvarval(EPCalcDaysr.CalcStr,vararrayobj,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
  end;
  i = i +1;
  EPCalcDaysr.Code =EPPayrollSetr.DayField3;
  if (ReadFirstMain(EPCalcDaysr,1,true)) then begin
    addvarval(EPCalcDaysr.CalcStr,vararray,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
    addvarval(EPCalcDaysr.CalcStr,vararrayobj,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
  end;
  i = i +1;
  EPCalcDaysr.Code =EPPayrollSetr.DayField4;
  if (ReadFirstMain(EPCalcDaysr,1,true)) then begin
    addvarval(EPCalcDaysr.CalcStr,vararray,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
    addvarval(EPCalcDaysr.CalcStr,vararrayobj,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
  end;
  i = i +1;
  EPCalcDaysr.Code =EPPayrollSetr.DayField5;
  if (ReadFirstMain(EPCalcDaysr,1,true)) then begin
    addvarval(EPCalcDaysr.CalcStr,vararray,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
    addvarval(EPCalcDaysr.CalcStr,vararrayobj,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
  end;
  i = i +1;
  EPCalcDaysr.Code =EPPayrollSetr.DayField6;
  if (ReadFirstMain(EPCalcDaysr,1,true)) then begin
    addvarval(EPCalcDaysr.CalcStr,vararray,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
    addvarval(EPCalcDaysr.CalcStr,vararrayobj,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
  end;
  i = i +1;
  EPCalcDaysr.Code =EPPayrollSetr.DayField7;
  if (ReadFirstMain(EPCalcDaysr,1,true)) then begin
    addvarval(EPCalcDaysr.CalcStr,vararray,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
    addvarval(EPCalcDaysr.CalcStr,vararrayobj,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
  end;
  i = i +1;
  EPCalcDaysr.Code =EPPayrollSetr.DayField8;
  if (ReadFirstMain(EPCalcDaysr,1,true)) then begin
    addvarval(EPCalcDaysr.CalcStr,vararray,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
    addvarval(EPCalcDaysr.CalcStr,vararrayobj,GetFieldValueByName(EPCalcresr,"UserDays" & i,-1)); 
  end;
return;
end;



global
procedure GetCurFakeRec(record EPCalcResVc EPCalcResr,var record EPCalcresVc EPCalcResr2,record SMVc vararrayobjold,record EPPayrollSetBlock EPPayrollSetr,record EPContractVc EPContractr,var val res)
begin
  record SMVc vararrayobj;
  record SMVc vararray;
  
  array string 20 trtypes;
  array val amounts;
  array integer doctypes;
  
  record TaxRepVc TaxRepr;
  record EPTrTypeVc EPTrTyper;
  row EPCalcResVc EPCalcResrw;
  row TaxRepVc Taxreprw;
  row EPContractVc EPContractrw;
  string 20 tempa,tempaobj;
  string 255 tstr;
  integer rwc,rw;
  integer i;
  integer size,ar,j,k,ark;
  transaction string 1 gDelimCharacter;
  val dayamount,whours;

  RecordCopy(EPCalcResr2,EPCalcResr);
  RecordCopy(vararrayobj,vararrayobjold);
  
  AddEPCalcDays(EPCalcResr2,vararray,vararrayobj,EPPayrollSetr);
  
  size = 0;
  CalculatePrivilegies(EPCalcResr2,trtypes,amounts,doctypes,size);
  rwc = MatRowCnt(EPCalcResr2);
  for (i = 0;i < size; i = i + 1) begin
    EPCalcresrw.Sum = round(amounts[i],SetRoundModeD(2));
    EPCalcresrw.TrType = trtypes[i];
    EPTrTyper.Code = trtypes[i];
    if (ReadFirstMain(EPTrTyper,1,true)) then begin
      EPCalcResrw.Comment = EPTrTyper.Name;
      EPCalcResrw.Objects = EPTrTyper.Objects;
    end;
    MatRowPut(EPCalcResr2,rwc,EPCalcresrw);
    rwc = rwc + 1;
  end;
  ar = MatRowCnt(EPCalcResr2);

  for (i=0;i<ar;i=i+1) begin
    MatRowGet(EPCalcResr2,i,EPCalcResrw);
    if (nonblank(EPCalcResrw.TrType)) then begin
      addvarvalAdd(EPCalcResrw.TrType,vararrayobj,ValToString(EPCalcResrw.Sum,M423Val,"",".",0));
      if(blank(EPCalcresrw.Objects)) then begin
        addvarvaladd(EPCalcResrw.TrType,vararray,ValToString(EPCalcResrw.Sum,M423Val,"",".",0));
      end;
    end;
  end;

  if (nonblank(EPContractr.Calc)) then begin
  TaxRepr.Code=EPContractr.Calc;
  end else begin
  TaxRepr.Code=EPPayrollSetr.Calc; 
  end;
  ark = MatRowCnt(EPContractr);
  if (Readfirstmain(TaxRepr,1,true)) then begin
    if (blank(TaxRepr.Delimiter)) then begin
    gDelimCharacter = ",";
  end else begin
    gDelimCharacter = TaxRepr.Delimiter;
  end;

    ar=MatrowCnt(TaxRepr);
    i = MatRowCnt(EPCalcresr2);
    for (j=0;j<ar;j=j+1) begin
      MatRowGet(TaxRepr,j,TaxReprw);
      tstr = TaxReprw.Formula;
      FindCalcResAvSal("AVSAL",EPCalcResr,tstr,tstr,dayamount);
      FindCalcResAvSal("HOURS",EPCalcResr,tstr,tstr,whours);
            
      EPFindSplitSalary(EPContractr,EPCalcResr,tstr,false,"");
      TaxReprw.Formula = tstr;
//      tempaobj=valtostring(FCALCWITHVARPayCheckSum(TaxReprw.Formula,vararrayobj,TaxReprw.FCode,EPCalcResr),M4Val,"",".",0);
      tempaobj = valtostring(FCALCWITHVARPay(TaxReprw.Formula,vararrayobj,TaxReprw.FCode),M423Val,"",".",0);  
      for (k=0;k<ark;k=k+1) begin
        MatRowGet(EPContractr,k,EPContractrw);
        if (EPContractrw.Type==0) and (EPContractrw.TrType==TaxReprw.FCode) then begin
          EPCalcResrw.TrType=TaxReprw.FCode;
          EPCalcResrw.Comment=EPContractrw.Text;
          EPTrTyper.Code = EPCalcResrw.TrType;
          EPCalcResrw.Objects = "";
          if (ReadFirstMain(EPtrTyper,1,true)) then begin                
              EPCalcResrw.Sum = StringToVal(tempaobj,M423Val);
              MatRowPut(EPCalcResr2,i,EPCalcResrw);
              i=i+1;
          end;
          k=ark;
        end;
      end;
    end;
  end;
  UpdateAvMonth(EPCalcresr2);
  res = EPCalcresr2.MonthSal;
return;
end;

